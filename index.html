<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.542">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Alice Cleynen">
<meta name="author" content="Louis Raynal">
<meta name="author" content="Jean-Michel Marin">
<meta name="dcterms.date" content="2023-12-14">
<meta name="keywords" content="classification, Random Forests, local methods">

<title>Local tree methods for classification: a review and some dead ends</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="published-202312-cleynen-local_files/libs/clipboard/clipboard.min.js"></script>
<script src="published-202312-cleynen-local_files/libs/quarto-html/quarto.js"></script>
<script src="published-202312-cleynen-local_files/libs/quarto-html/popper.min.js"></script>
<script src="published-202312-cleynen-local_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="published-202312-cleynen-local_files/libs/quarto-html/anchor.min.js"></script>
<link href="published-202312-cleynen-local_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="published-202312-cleynen-local_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="published-202312-cleynen-local_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="published-202312-cleynen-local_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="published-202312-cleynen-local_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="citation_title" content="Local tree methods for classification: a review and some dead ends">
<meta name="citation_abstract" content="Random Forests (RF) [@breiman:2001] are very popular machine learning methods. They perform well even with little or no tuning, and have some theoretical guarantees, especially for sparse problems [@biau:2012;@scornet:etal:2015]. These learning strategies have been used in several contexts, also outside the field of classification and regression. To perform Bayesian model selection in the case of intractable likelihoods, the ABC Random Forests (ABC-RF) strategy of @pudlo:etal:2016 consists in applying Random Forests on training sets composed of simulations coming from the Bayesian generative models. The ABC-RF technique is based on an underlying RF for which the training and prediction phases are separated. The training phase does not take into account the data to be predicted. This seems to be suboptimal as in the ABC framework only one observation is of interest for the prediction. In this paper, we study tree-based methods that are built to predict a specific instance in a classification setting. This type of methods falls within the scope of local (lazy/instance-based/case specific) classification learning. We review some existing strategies and propose two new ones. The first consists in modifying the tree splitting rule by using kernels, the second in using a first RF to compute some local variable importance that is used to train a second, more local, RF. Unfortunately, these approaches, although interesting, do not provide conclusive results.
">
<meta name="citation_keywords" content="classification,Random Forests,local methods">
<meta name="citation_author" content="Alice Cleynen">
<meta name="citation_author" content="Louis Raynal">
<meta name="citation_author" content="Jean-Michel Marin">
<meta name="citation_publication_date" content="2023-12-14">
<meta name="citation_cover_date" content="2023-12-14">
<meta name="citation_year" content="2023">
<meta name="citation_online_date" content="2023-12-14">
<meta name="citation_fulltext_html_url" content="https://computo.sfds.asso.fr/published-202312-cleynen-local/">
<meta name="citation_pdf_url" content="https://computo.sfds.asso.fr/published-202312-cleynen-local/published-202312-cleynen-local.pdf">
<meta name="citation_doi" content="10.57750/3j8m-8d57">
<meta name="citation_issn" content="2824-7795">
<meta name="citation_language" content="en">
<meta name="citation_journal_title" content="Computo">
<meta name="citation_publisher" content="French Statistical Society">
<meta name="citation_reference" content="citation_title=Instance-based learning algorithms;,citation_author=D. W. Aha;,citation_author=D. Kibler;,citation_author=M. K. Albert;,citation_publication_date=1991;,citation_cover_date=1991;,citation_year=1991;,citation_volume=6;,citation_journal_title=Machine Learning;">
<meta name="citation_reference" content="citation_title=Lazy Learning;,citation_editor=D. W. Aha;,citation_publication_date=1997;,citation_cover_date=1997;,citation_year=1997;">
<meta name="citation_reference" content="citation_title=Enriched random forests;,citation_author=D. Amaratunga;,citation_author=J. Cabrera;,citation_author=Y.-S. Lee;,citation_publication_date=2008;,citation_cover_date=2008;,citation_year=2008;,citation_issue=18;,citation_volume=24;,citation_journal_title=Bioinformatics;">
<meta name="citation_reference" content="citation_title=Building forests of local trees;,citation_author=G. Armano;,citation_author=E. Tamponi;,citation_publication_date=2018;,citation_cover_date=2018;,citation_year=2018;,citation_volume=76;,citation_journal_title=Pattern Recognition;">
<meta name="citation_reference" content="citation_title=Approximate Bayesian computation in population genetics;,citation_author=M. Beaumont;,citation_author=W. Zhang;,citation_author=D. Balding;,citation_publication_date=2002;,citation_cover_date=2002;,citation_year=2002;,citation_issue=4;,citation_volume=162;,citation_journal_title=Genetics;">
<meta name="citation_reference" content="citation_title=Analysis of a random forest model;,citation_author=G. Biau;,citation_publication_date=2012;,citation_cover_date=2012;,citation_year=2012;,citation_volume=13;,citation_journal_title=Journal of Machine Learning Research;">
<meta name="citation_reference" content="citation_title=Supervised neighborhoods for distributed nonparametric regression;,citation_author=A. Bloniarz;,citation_author=C. Wu;,citation_author=B. Yu;,citation_author=A. Talwalkar;,citation_publication_date=2016;,citation_cover_date=2016;,citation_year=2016;,citation_volume=51;,citation_journal_title=Proceedings of the 19th International Conference on Artificial Intelligence and Statistics;">
<meta name="citation_reference" content="citation_title=Non-linear regression models for approximate Bayesian computation;,citation_author=M. G. B. Blum;,citation_author=O. François;,citation_publication_date=2010;,citation_cover_date=2010;,citation_year=2010;,citation_volume=20;,citation_journal_title=Statistics and Computing;">
<meta name="citation_reference" content="citation_title=A comparative review of dimension reduction methods in approximate Bayesian computation;,citation_author=M. G. B. Blum;,citation_author=M. Nunes;,citation_author=D. Prangle;,citation_author=S. A. Sisson;,citation_publication_date=2013;,citation_cover_date=2013;,citation_year=2013;,citation_issue=2;,citation_volume=28;,citation_journal_title=Statistical Science;">
<meta name="citation_reference" content="citation_title=Classification and regression trees;,citation_author=L. Breiman;,citation_author=J. Friedman;,citation_author=C. J. Stone;,citation_author=R. A. Olshen;,citation_publication_date=1984;,citation_cover_date=1984;,citation_year=1984;,citation_series_title=The wadsworth and brooks-cole statistics-probability series;">
<meta name="citation_reference" content="citation_title=Bagging predictors;,citation_author=undefined Breiman;,citation_publication_date=1996;,citation_cover_date=1996;,citation_year=1996;,citation_volume=24;,citation_journal_title=Machine Learning;">
<meta name="citation_reference" content="citation_title=Random forests;,citation_author=undefined Breiman;,citation_publication_date=2001;,citation_cover_date=2001;,citation_year=2001;,citation_volume=45;,citation_journal_title=Machine Learning;">
<meta name="citation_reference" content="citation_title=Semi-supervised learning;,citation_author=O. Chapelle;,citation_author=B. Schölkopf;,citation_author=A. Zien;,citation_publication_date=2010;,citation_cover_date=2010;,citation_year=2010;,citation_series_title=Adaptive computation and machine learning;">
<meta name="citation_reference" content="citation_title=Robust Locally Weighted Regression and Smoothing Scatterplots;,citation_author=W. Cleveland;,citation_publication_date=1979;,citation_cover_date=1979;,citation_year=1979;,citation_issue=368;,citation_volume=74;,citation_journal_title=Journal of the American Statistical Association;">
<meta name="citation_reference" content="citation_title=Locally Weighted Regression: An Approach to Regression Analysis by Local Fitting;,citation_author=W. Cleveland;,citation_publication_date=1988;,citation_cover_date=1988;,citation_year=1988;,citation_issue=403;,citation_volume=83;,citation_journal_title=Journal of the American Statistical Association;">
<meta name="citation_reference" content="citation_title=DIYABC v2.0: A software to make approximate bayesian computation inferences about population history using single nucleotide polymorphism, DNA sequence and microsatellite data;,citation_author=J.-M. Cornuet;,citation_author=P. Pudlo;,citation_author=J. Veyssier;,citation_author=A. Dehne-Garcia;,citation_author=M. Gautier;,citation_author=R. Leblois;,citation_author=J.-M. Marin;,citation_author=A. Estoup;,citation_publication_date=2014;,citation_cover_date=2014;,citation_year=2014;,citation_issue=8;,citation_volume=30;,citation_journal_title=Bioinformatics;">
<meta name="citation_reference" content="citation_title=Approximate Bayesian computation (ABC) in practice;,citation_author=K. Csilléry;,citation_author=M. G. B. Blum;,citation_author=O. E. Gaggiotti;,citation_author=O. François;,citation_publication_date=2010;,citation_cover_date=2010;,citation_year=2010;,citation_volume=25;,citation_journal_title=Trends in Ecology and Evolution;">
<meta name="citation_reference" content="citation_title=Multi-interval discretization of continuous-valued attributes for classification learning;,citation_author=U. M. Fayyad;,citation_author=K. B. Irani;,citation_publication_date=1995;,citation_cover_date=1995;,citation_year=1995;,citation_volume=2;,citation_journal_title=Proceedings of the 13th International Joint Conference on Artificial Intelligence;">
<meta name="citation_reference" content="citation_title=Local linear regression smoothers and their minimax efficiencies;,citation_author=J. Fan;,citation_publication_date=1993;,citation_cover_date=1993;,citation_year=1993;,citation_issue=1;,citation_volume=21;,citation_journal_title=The Annals of Statistics;">
<meta name="citation_reference" content="citation_title=Boosting lazy decision trees;,citation_author=X. Z Fern;,citation_author=C. E Brodley;,citation_publication_date=2003;,citation_cover_date=2003;,citation_year=2003;,citation_issue=1;,citation_volume=20;,citation_journal_title=Proceedings of the Twentieth International Conference on Machine Learning;">
<meta name="citation_reference" content="citation_title=Lazy decision trees;,citation_author=J. H. Friedman;,citation_author=R. Kohavi;,citation_author=Y. Yun;,citation_publication_date=1997;,citation_cover_date=1997;,citation_year=1997;,citation_journal_title=Proceedings of the 13th National Conference on AAAI;">
<meta name="citation_reference" content="citation_title=Local induction of decision trees: Towards interactive data mining;,citation_author=T. Fulton;,citation_author=S. Kasif;,citation_author=S. Salzberg;,citation_author=D. L. Waltz;,citation_publication_date=1996;,citation_cover_date=1996;,citation_year=1996;,citation_conference_title=Proceedings of the second international conference on knowledge discovery and data mining;,citation_conference=AAAI Press;">
<meta name="citation_reference" content="citation_title=A lazy approach for machine learning algorithms;,citation_author=I. M. Galván;,citation_author=J. M. Valls;,citation_author=N. Lecomte;,citation_author=P. Isasi;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_volume=296;,citation_journal_title=IFIP International Federation for Information Processing;">
<meta name="citation_reference" content="citation_title=Learning by transduction;,citation_author=A. Gammerman;,citation_author=V. Vovk;,citation_author=V. Vapnik;,citation_publication_date=1998;,citation_cover_date=1998;,citation_year=1998;,citation_conference_title=Proceedings of the fourteenth conference on uncertainty in artificial intelligence;,citation_conference=Morgan Kaufmann Publishers Inc.;,citation_series_title=UAI’98;">
<meta name="citation_reference" content="citation_title=Local regression: Automatic kernel carpentry (with discussion);,citation_author=T. Hastie;,citation_author=C. Loader;,citation_publication_date=1993;,citation_cover_date=1993;,citation_year=1993;,citation_issue=2;,citation_volume=8;,citation_journal_title=Statistical Science;">
<meta name="citation_reference" content="citation_title=Random forests and adaptive nearest neighbors;,citation_author=Y. Lin;,citation_author=Y. Jeon;,citation_publication_date=2006;,citation_cover_date=2006;,citation_year=2006;,citation_volume=101;,citation_journal_title=Journal of the American Statistical Association;">
<meta name="citation_reference" content="citation_title=Improved class probability estimates from decision tree models;,citation_author=D. D. Margineantu;,citation_author=T. G. Dietterich;,citation_publication_date=2003;,citation_cover_date=2003;,citation_year=2003;,citation_volume=171;,citation_journal_title=Lecture Notes in Statistics - Nonlinear Estimation and Classification;">
<meta name="citation_reference" content="citation_title=Approximate Bayesian computational methods;,citation_author=J.-M. Marin;,citation_author=P. Pudlo;,citation_author=C. P. Robert;,citation_author=R. Ryder;,citation_publication_date=2011;,citation_cover_date=2011;,citation_year=2011;,citation_volume=22;,citation_journal_title=Statistics and Computing;">
<meta name="citation_reference" content="citation_title=Random feature weights for decision tree ensemble construction;,citation_author=J. Maudes;,citation_author=J. J. Rodríguez;,citation_author=C. Carcía-Osorio;,citation_author=N. Garcá-Pedrajas;,citation_publication_date=2012;,citation_cover_date=2012;,citation_year=2012;,citation_issue=1;,citation_volume=13;,citation_journal_title=Information Fusion;">
<meta name="citation_reference" content="citation_title=Quantile regression forests;,citation_author=N. Meinshausen;,citation_publication_date=2006;,citation_cover_date=2006;,citation_year=2006;,citation_volume=7;,citation_journal_title=Journal of Machine Learning Research;">
<meta name="citation_reference" content="citation_title=Population growth of human Y chromosomes: A study of Y chromosome microsatellites;,citation_author=J. K. Pritchard;,citation_author=M. T. Seielstad;,citation_author=A. Perez-Lezaun;,citation_author=M. W. Feldman;,citation_publication_date=1999;,citation_cover_date=1999;,citation_year=1999;,citation_volume=16;,citation_journal_title=Molecular Biology and Evolution;">
<meta name="citation_reference" content="citation_title=Reliable ABC model choice via random forests;,citation_author=P. Pudlo;,citation_author=J.-M. Marin;,citation_author=A. Estoup;,citation_author=J.-M. Cornuet;,citation_author=M. Gautier;,citation_author=C. P. Robert;,citation_publication_date=2016;,citation_cover_date=2016;,citation_year=2016;,citation_issue=6;,citation_volume=32;,citation_journal_title=Bioinformatics;">
<meta name="citation_reference" content="citation_title=ABC random forests for Bayesian parameter inference;,citation_author=L. Raynal;,citation_author=J.-M. Marin;,citation_author=P. Pudlo;,citation_author=M. Ribatet;,citation_author=C. P. Robert;,citation_author=A. Estoup;,citation_publication_date=2019;,citation_cover_date=2019;,citation_year=2019;,citation_issue=10;,citation_volume=35;,citation_journal_title=Bioinformatics;">
<meta name="citation_reference" content="citation_title=Improving random forests;,citation_author=M. Robnik-Šikonja;,citation_editor=Jean-François Boulicaut;,citation_editor=Floriana Esposito;,citation_editor=Fosca Giannotti;,citation_editor=Dino Pedreschi;,citation_publication_date=2004;,citation_cover_date=2004;,citation_year=2004;,citation_conference_title=Machine learning: ECML 2004;,citation_conference=Springer Berlin, Heidelberg;">
<meta name="citation_reference" content="citation_title=Learning with few examples by transferring feature relevance;,citation_author=E. Rodner;,citation_author=J. Denzler;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_volume=5748 LNCS;,citation_journal_title=Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics);">
<meta name="citation_reference" content="citation_title=Improving random forests by neighborhood projection for effective text classification;,citation_author=T. Salles;,citation_author=M. Gonçalves;,citation_author=V. Rodrigues;,citation_author=L. Rocha;,citation_publication_date=2018;,citation_cover_date=2018;,citation_year=2018;,citation_volume=77;,citation_journal_title=Information Systems;">
<meta name="citation_reference" content="citation_title=Consistency of random forests;,citation_author=E. Scornet;,citation_author=G. Biau;,citation_author=J.-P. Vert;,citation_publication_date=2015;,citation_cover_date=2015;,citation_year=2015;,citation_issue=4;,citation_volume=43;,citation_journal_title=Annals of Statistics;">
<meta name="citation_reference" content="citation_title=Inferring coalescence times from DNA sequence data;,citation_author=S. Tavaré;,citation_author=D. Balding;,citation_author=R. Griffiths;,citation_author=P. Donnelly;,citation_publication_date=1997;,citation_cover_date=1997;,citation_year=1997;,citation_issue=2;,citation_volume=145;,citation_journal_title=Genetics;">
<meta name="citation_reference" content="citation_title=Dynamic integration with random forests;,citation_author=A. Tsymbal;,citation_author=M. Pechenizkiy;,citation_author=Pádraig Cunningham;,citation_editor=J. Fürnkranz;,citation_editor=T. Scheffer;,citation_editor=M. Spiliopoulou;,citation_publication_date=2006;,citation_cover_date=2006;,citation_year=2006;,citation_conference_title=Machine learning: ECML 2006. ECML 2006. Lecture notes in computer science;,citation_conference=Springer Berlin, Heidelberg;">
<meta name="citation_reference" content="citation_title=Ranger: A fast implementation of random forests for high dimensional data in C++ and R;,citation_author=M. N. Wright;,citation_author=A. Ziegler;,citation_publication_date=2017;,citation_cover_date=2017;,citation_year=2017;,citation_issue=1;,citation_volume=77;,citation_journal_title=Journal of Statistical Software;">
<meta name="citation_reference" content="citation_title=Case-specific random forests;,citation_author=R. Xu;,citation_author=D. Nettleton;,citation_author=D. J. Nordman;,citation_publication_date=2016;,citation_cover_date=2016;,citation_year=2016;,citation_issue=1;,citation_volume=25;,citation_journal_title=Journal of Computational and Graphical Statistics;">
<meta name="citation_reference" content="citation_title=Instance based random forest with rotated feature space;,citation_author=L. Zhang;,citation_author=Y. Ren;,citation_author=P. N. Suganthan;,citation_publication_date=2013;,citation_cover_date=2013;,citation_year=2013;,citation_conference_title=2013 IEEE symposium on computational intelligence and ensemble learning (CIEL);">
<meta name="citation_reference" content="citation_title=Local linear forests;,citation_author=Rina Friedberg;,citation_author=Julie Tibshirani;,citation_author=Susan Athey;,citation_author=Stefan Wager;,citation_publication_date=2020;,citation_cover_date=2020;,citation_year=2020;,citation_issue=2;,citation_volume=30;,citation_journal_title=Journal of Computational and Graphical Statistics;,citation_publisher=Taylor &amp;amp;amp; Francis;">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Local tree methods for classification: a review and some dead ends</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://alice.cleynen.fr/">Alice Cleynen</a> <a href="https://orcid.org/0000-0001-8083-0204" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://imag.umontpellier.fr/">
                  IMAG, Univ Montpellier, CNRS, UMR 5149, Montpellier, France
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        Louis Raynal <a href="https://orcid.org/0000-0003-2805-3254" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  Centre Hospitalier Départemental Vendée, La Roche-sur-Yon, France
                </p>
              <p class="affiliation">
                  <a href="https://www.chd-vendee.fr/">
                  
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://imag.umontpellier.fr/~marin/">Jean-Michel Marin</a> <a href="https://orcid.org/0000-0001-7451-9719" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://imag.umontpellier.fr/">
                  IMAG, Univ Montpellier, CNRS, UMR 5149, Montpellier, France
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 14, 2023</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">January 14, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">classification, Random Forests, local methods</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <a href="https://github.com/computorg/published-202312-cleynen-local"><img src="https://github.com/computorg/published-202312-cleynen-local/actions/workflows/build.yml/badge.svg" alt="build status"></a>
                    <p class="date"></p>
        <a href="https://github.com/computorg/published-202312-cleynen-local/issues?q=is%3Aopen+is%3Aissue+label%3Areview"><img src="https://img.shields.io/badge/reviews-reports-blue" alt="reviews"></a>
            </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>Random Forests (RF) <span class="citation" data-cites="breiman:2001">(<a href="#ref-breiman:2001" role="doc-biblioref">Breiman 2001</a>)</span> are very popular machine learning methods. They perform well even with little or no tuning, and have some theoretical guarantees, especially for sparse problems <span class="citation" data-cites="biau:2012 scornet:etal:2015">(<a href="#ref-biau:2012" role="doc-biblioref">Biau 2012</a>; <a href="#ref-scornet:etal:2015" role="doc-biblioref">Scornet, Biau, and Vert 2015</a>)</span>. These learning strategies have been used in several contexts, also outside the field of classification and regression. To perform Bayesian model selection in the case of intractable likelihoods, the ABC Random Forests (ABC-RF) strategy of <span class="citation" data-cites="pudlo:etal:2016">Pudlo et al. (<a href="#ref-pudlo:etal:2016" role="doc-biblioref">2016</a>)</span> consists in applying Random Forests on training sets composed of simulations coming from the Bayesian generative models. The ABC-RF technique is based on an underlying RF for which the training and prediction phases are separated. The training phase does not take into account the data to be predicted. This seems to be suboptimal as in the ABC framework only one observation is of interest for the prediction. In this paper, we study tree-based methods that are built to predict a specific instance in a classification setting. This type of methods falls within the scope of local (lazy/instance-based/case specific) classification learning. We review some existing strategies and propose two new ones. The first consists in modifying the tree splitting rule by using kernels, the second in using a first RF to compute some local variable importance that is used to train a second, more local, RF. Unfortunately, these approaches, although interesting, do not provide conclusive results.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-recallsRF" id="toc-sec-recallsRF" class="nav-link" data-scroll-target="#sec-recallsRF"><span class="header-section-number">2</span> Reminders on Breiman’s random forest</a></li>
  <li><a href="#sec-localSplittingRules" id="toc-sec-localSplittingRules" class="nav-link" data-scroll-target="#sec-localSplittingRules"><span class="header-section-number">3</span> Local splitting rules</a>
  <ul class="collapse">
  <li><a href="#sec-lazyDT" id="toc-sec-lazyDT" class="nav-link" data-scroll-target="#sec-lazyDT"><span class="header-section-number">3.1</span> Lazy decision trees</a></li>
  <li><a href="#sec-localKernel" id="toc-sec-localKernel" class="nav-link" data-scroll-target="#sec-localKernel"><span class="header-section-number">3.2</span> Unidimensional (per covariate) kernel approach</a></li>
  <li><a href="#sec-localKernelMultiDim" id="toc-sec-localKernelMultiDim" class="nav-link" data-scroll-target="#sec-localKernelMultiDim"><span class="header-section-number">3.3</span> Multidimensional kernel approach</a></li>
  </ul></li>
  <li><a href="#sec-localWeightingOfIndividuls" id="toc-sec-localWeightingOfIndividuls" class="nav-link" data-scroll-target="#sec-localWeightingOfIndividuls"><span class="header-section-number">4</span> Local weighting of individuals</a>
  <ul class="collapse">
  <li><a href="#sec-weightingIndividuals" id="toc-sec-weightingIndividuals" class="nav-link" data-scroll-target="#sec-weightingIndividuals"><span class="header-section-number">4.1</span> Weighted bootstrap</a></li>
  <li><a href="#sec-nearest-neighbours" id="toc-sec-nearest-neighbours" class="nav-link" data-scroll-target="#sec-nearest-neighbours"><span class="header-section-number">4.2</span> Nearest neighbours: 0/1 weights</a></li>
  </ul></li>
  <li><a href="#sec-weightingCovariates" id="toc-sec-weightingCovariates" class="nav-link" data-scroll-target="#sec-weightingCovariates"><span class="header-section-number">5</span> Local weighting of covariates</a></li>
  <li><a href="#sec-treeWeights" id="toc-sec-treeWeights" class="nav-link" data-scroll-target="#sec-treeWeights"><span class="header-section-number">6</span> Local weighting of votes</a>
  <ul class="collapse">
  <li><a href="#sec-dynamicVoting" id="toc-sec-dynamicVoting" class="nav-link" data-scroll-target="#sec-dynamicVoting"><span class="header-section-number">6.1</span> Dynamic voting and selection</a></li>
  <li><a href="#sec-kernelVoting" id="toc-sec-kernelVoting" class="nav-link" data-scroll-target="#sec-kernelVoting"><span class="header-section-number">6.2</span> Kernel weighted voting</a></li>
  </ul></li>
  <li><a href="#sec-examples" id="toc-sec-examples" class="nav-link" data-scroll-target="#sec-examples"><span class="header-section-number">7</span> Numerical experiments</a>
  <ul class="collapse">
  <li><a href="#sec-gaussianExample" id="toc-sec-gaussianExample" class="nav-link" data-scroll-target="#sec-gaussianExample"><span class="header-section-number">7.1</span> Balanced Gaussian mixture example</a></li>
  <li><a href="#sec-gaussianExampleUnbalanced" id="toc-sec-gaussianExampleUnbalanced" class="nav-link" data-scroll-target="#sec-gaussianExampleUnbalanced"><span class="header-section-number">7.2</span> Unbalanced Gaussian mixture example</a></li>
  <li><a href="#sec-SphereExample" id="toc-sec-SphereExample" class="nav-link" data-scroll-target="#sec-SphereExample"><span class="header-section-number">7.3</span> Spherical fragmented example</a></li>
  <li><a href="#sec-geneticsExample" id="toc-sec-geneticsExample" class="nav-link" data-scroll-target="#sec-geneticsExample"><span class="header-section-number">7.4</span> Population genetics example</a></li>
  </ul></li>
  <li><a href="#sec-reproducibility" id="toc-sec-reproducibility" class="nav-link" data-scroll-target="#sec-reproducibility"><span class="header-section-number">8</span> Data accessibility and reproducibility</a></li>
  <li><a href="#sec-discussions" id="toc-sec-discussions" class="nav-link" data-scroll-target="#sec-discussions"><span class="header-section-number">9</span> Discussions</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements"><span class="header-section-number">10</span> Acknowledgements</a></li>
  <li><a href="#funding" id="toc-funding" class="nav-link" data-scroll-target="#funding"><span class="header-section-number">11</span> Funding</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="published-202312-cleynen-local.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p><span class="math inline">\newcommand{\diag}{\operatorname{diag}}</span> <span class="math inline">\newcommand{\var}{\mathrm{Var}}</span> <span class="math inline">\newcommand{\xs}{x^*}</span> <span class="math inline">\newcommand{\xsj}{x_j^*}</span> <span class="math inline">\newcommand{\xsij}{x_j^{*(i)}}</span> <span class="math inline">\newcommand{\inroot}{\in\text{ROOT}}</span> <span class="math inline">\newcommand{\idxi}{^{(i)}}</span> <span class="math inline">\newcommand{\Nmin}{N_{\text{min}}}</span> <span class="math inline">\newcommand{\mtry}{m_{\text{try}}}</span> <span class="math inline">\newcommand{\indicator}{\mathds{1}}</span> <span class="math inline">\renewcommand{\P}{\mathbb{P}}</span></p>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>The machine learning field of local/lazy/instance-based/case-specific learning <span class="citation" data-cites="aha:etal:1991">(<a href="#ref-aha:etal:1991" role="doc-biblioref">Aha, Kibler, and Albert 1991</a>)</span> aims at taking into account a particular instance <span class="math inline">x^*</span> to produce a prediction thanks to its similarity to the training data set. It is opposed to eager learning, where the prediction is divided in two parts: a training phase where a global model is fitted and then a prediction phase. The local approach, in contrast, fits a model taking into account the information provided by <span class="math inline">x^*</span>.</p>
<p>Two closely related learning fields need to be mentioned: semi-supervised learning <span class="citation" data-cites="chapelle:etal:2010">(<a href="#ref-chapelle:etal:2010" role="doc-biblioref">Chapelle, Schölkopf, and Zien 2010</a>)</span> and transductive learning <span class="citation" data-cites="gammerman:etal:1998">(<a href="#ref-gammerman:etal:1998" role="doc-biblioref">Gammerman, Vovk, and Vapnik 1998</a>)</span>. Semi-supervised learning introduces unlabeled data (whose response is unknown) in addition to labeled ones to build a general model within the training phase. Then, in the testing phase this model is used to predict the response value of a new unlabeled data (different from the first ones). Transductive learning takes profit of a set of labeled and unlabelled data to avoid the construction of a general model and directly predicts the response values of those same unlabeled data. To our knowledge, semi-supervised and transductive learning require a high number of test/unlabeled instances. In our case only one is provided, making those approaches unsuitable.</p>
<p>The main drawback of local learning approaches is their high computational cost, because for each new test data a model has to be constructed. However, it can be very useful in domains where only one test instance is provided.</p>
<p>Approximate Bayesian computation (ABC, <span class="citation" data-cites="tavare:etal:1997">Tavaré et al. (<a href="#ref-tavare:etal:1997" role="doc-biblioref">1997</a>)</span>; <span class="citation" data-cites="pritchard:etal:1999">Pritchard et al. (<a href="#ref-pritchard:etal:1999" role="doc-biblioref">1999</a>)</span>) is a statistical method developed for frameworks where the likelihood is intractable. It relies on simulations according to Bayesian hierarchical models to generate pseudo-data. These artificial data are then compared to the test/observed one. To this effect , the most basic algorithm is based on nearest neighbors (NN). Recently, <span class="citation" data-cites="breiman:2001">Breiman (<a href="#ref-breiman:2001" role="doc-biblioref">2001</a>)</span>’s machine learning algorithm of random forests (RF) proved to bring a meaningful improvement to the ABC paradigm in both a context of model choice <span class="citation" data-cites="pudlo:etal:2016">(<a href="#ref-pudlo:etal:2016" role="doc-biblioref">Pudlo et al. 2016</a>)</span> and parameter inference <span class="citation" data-cites="raynal:etal:2019">(<a href="#ref-raynal:etal:2019" role="doc-biblioref">Raynal et al. 2019</a>)</span>. Here, we focus on the model choice problem and thus the classification setting. Unlike some ABC techniques that take advantage of local methods, such as local adjustment <span class="citation" data-cites="beaumont:etal:2002 blum:francois:2010 blum:etal:2013">(<a href="#ref-beaumont:etal:2002" role="doc-biblioref">Beaumont, Zhang, and Balding 2002</a>; <a href="#ref-blum:francois:2010" role="doc-biblioref">Blum and François 2010</a>; <a href="#ref-blum:etal:2013" role="doc-biblioref">Blum et al. 2013</a>)</span>, ABC-RF trains an eager RF to predict, later on, the observed data. It seems sub-optimal because in the ABC framework only the observed data is of interest for prediction. The ABC-RF strategy might therefore greatly benefit from local versions of RF.</p>
<p>Here, we focus on reviewing and proposing tree-based method to predict at best a specific data of interest. We start with some reminders on <span class="citation" data-cites="breiman:2001">Breiman (<a href="#ref-breiman:2001" role="doc-biblioref">2001</a>)</span>’s RF algorithm. We then study local tree-based approaches depending on the way the localization process is performed. In <a href="#sec-localSplittingRules" class="quarto-xref">Section&nbsp;3</a>, we introduce internal modifications of the RF concerning the splitting rule. Then, we take an interest on modifying the random aspects of RF to turn them into local ones. We focus on modifying the sampling of individuals in <a href="#sec-localWeightingOfIndividuls" class="quarto-xref">Section&nbsp;4</a>, and the sampling of predictors in <a href="#sec-weightingCovariates" class="quarto-xref">Section&nbsp;5</a>. Local weighting of votes is finally presented in <a href="#sec-treeWeights" class="quarto-xref">Section&nbsp;6</a>. We empirically compare these strategies with the original, eager one in four examples where a local approach might be of interest.</p>
</section>
<section id="sec-recallsRF" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Reminders on Breiman’s random forest</h1>
<p>In the following we consider a classification problem. We use a set of <span class="math inline">d</span> explanatory variables <span class="math inline">X=(X_1, \ldots, X_d)</span> to predict the categorical/discrete response <span class="math inline">Y</span> belonging to <span class="math inline">\{1,\dots,K\}</span>..</p>
<p>The training data set is composed of <span class="math inline">N</span> realizations <span class="math inline">\big\{ (y^{(i)}, x^{(i)}) \big\}_{i=1,\ldots,N}</span>. We consider <span class="citation" data-cites="breiman:2001">Breiman (<a href="#ref-breiman:2001" role="doc-biblioref">2001</a>)</span>’s random forest as the reference method to improve.</p>
<p>An RF is a set of randomized trees <span class="citation" data-cites="breiman:etal:1984">(<a href="#ref-breiman:etal:1984" role="doc-biblioref">L. Breiman et al. 1984</a>)</span>, each one partitioning the covariates space thanks to a series of allocation rules and assigning a class label as prediction to each partition. A binary tree is composed of internal and terminal nodes (a.k.a. leaves). For each internal node, a splitting rule on an explanatory variable is determined by maximizing an information gain, dividing the training set in two parts. This process is recursively iterated until a stopping rule is achieved. The internal node encountering a stopping rule becomes terminal. For continuous covariates, a splitting rule compares a covariate <span class="math inline">X_j</span> to a bound <span class="math inline">s</span>, allocating to the left branch the data verifying the rule <span class="math inline">X_j \leq s</span>, and to the right all others. For categorical covariates, the splitting rule is chosen among all the possible two-way splits of the covariate categories.</p>
<p>The covariate index <span class="math inline">j</span> and the bound <span class="math inline">s</span> are chosen to maximize the decrease of impurity between the mother, denoted <span class="math inline">t</span>, and the two resulting left and right daughter nodes, denoted <span class="math inline">t_L</span> and <span class="math inline">t_R</span>, (weighted by the number of data at each node). This gain associated to a covariate <span class="math inline">j</span> and split value <span class="math inline">s</span> is always non negative and is written as</p>
<p><span id="eq-critRF"><span class="math display">
    G(j,s) = I(t) - \left( \frac{\#t_L}{\#t} I(t_L) + \frac{\#t_R}{\#t} I(t_R) \right),
\tag{1}</span></span></p>
<p>where <span class="math inline">\#</span> refers to the number of data in the associated node, and <span class="math inline">I(\cdot)</span> is the impurity. The impurity, i.e.&nbsp;the heterogeneity at a given node, is measured with either the Gini index or the entropy. The Gini index, defined for categorical variables as <span class="math inline">\sum_{k=1}^K p_k(1-p_k)</span>, is less computationally intensive as is counterpart, the entropy, defined as <span class="math inline">\sum_{k=1}^K p_k\log(p_k)</span> which gives slightly better results. In both cases, the objective is to select the allocation rule that reduces the impurity the most, in other terms that produces the highest gain.</p>
<p>Splitting events stop when one of the three following situation is reached:</p>
<ul>
<li>all individuals of the data set at a given node have the same response value (the node is pure),</li>
<li>all individuals have the same covariate values,</li>
<li>a node has less than <span class="math inline">N_{\text{min}}</span> instances, <span class="math inline">N_{\text{min}}</span> being an user-defined integer value, typically set to 1 for classification.</li>
</ul>
<p>Once the tree construction is complete, each leaf predicts a model index, corresponding to the majority class of its instances. For a new set of explanatory variables <span class="math inline">x^*</span>, predicting its model index implies passing <span class="math inline">x^*</span> through the tree, following the path of binary rules, and the predicted value is the value associated to the leaf where it falls.</p>
<p>The RF method consists in bootstrap aggregating (bagging, <span class="citation" data-cites="breiman:1996">Breiman (<a href="#ref-breiman:1996" role="doc-biblioref">1996</a>)</span>) randomized (classification) trees. A large number of trees is trained on bootstrap samples of the training data set and <span class="math inline">m_{\text{try}}</span> covariates are randomly selected at each internal node, on which the splitting rule will be defined. <span class="math inline">m_{\text{try}}</span> is usually set at <span class="math inline">\lfloor \sqrt{d} \rfloor</span>, where <span class="math inline">\lfloor \cdot \rfloor</span> denotes the floor function. The predicted value for a data <span class="math inline">x^*</span> is the majority vote across all tree predictions. RF methods have some theoretical guarantees for sparse problems <span class="citation" data-cites="biau:2012 scornet:etal:2015">(<a href="#ref-biau:2012" role="doc-biblioref">Biau 2012</a>; <a href="#ref-scornet:etal:2015" role="doc-biblioref">Scornet, Biau, and Vert 2015</a>)</span>. Moreover, it is well-known that their performances are quite good even when no tuning is made.</p>
</section>
<section id="sec-localSplittingRules" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Local splitting rules</h1>
<p>We now turn to discuss local tree methods. A first option to localize the tree construction is to change the information gain to the benefit of a local one. The idea is to use the test instance <span class="math inline">x^*</span> to drive the splits and thus the tree construction.</p>
<p>Indeed, because the best split is selected on average, an eager tree may lead to many irrelevant splits to predict <span class="math inline">x^*</span>, potentially discarding data relevant for the considered example at early stages of the tree. This behavior results from data fragmentation <span class="citation" data-cites="fulton:etal:1996">(<a href="#ref-fulton:etal:1996" role="doc-biblioref">Fulton et al. 1996</a>)</span>, i.e.&nbsp;from the recursive partitioning of the explanatory variables space to achieve good global performances. In the following we mention this phenomenon as the fragmentation problem. A very simple 2-class classification problem presented in <a href="#fig-4Unif" class="quarto-xref">Figure&nbsp;1</a> illustrates this issue. The distribution of the training data set will induce, when possible, an initial cut for the tree construction in <span class="math inline">X_1\approx0.5</span>, however, the unlabeled instance (represented by a black star) is in a region where a lot of relevant instances will be discarded after this first data split. A more pertinent first cut should occur in <span class="math inline">X_2\approx0.25</span>. This problem, called fragmentation problem, also leads to less significant splitting rules at deeper levels of the tree construction since based on fewer instances. It is thus interesting to consider a local approach taking <span class="math inline">x^*</span> into account.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-4Unif" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-4Unif-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-202312-cleynen-local_files/figure-html/fig-4Unif-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4Unif-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: An illustrative classification problem with 2 classes (purple and sky blye), containing two covariates describing four distinguishable regions (delimited by orange dashed lines) and an unlabeled data to classify (black star). This case will give rise to a fragmentation problem.
</figcaption>
</figure>
</div>
</div>
</div>
<p>It is interesting to note that building a local tree by modifying its internal construction results in building a single trajectory only, since the splitting rules are only applied on branches containing <span class="math inline">x^*</span>. A local tree is therefore a tool to recursively remove non-relevant data points from the classifier rule. Thus, a local random forest might be much faster for its construction compared to the eager version, especially if only one instance is of interest.</p>
<p>In this section we present the approach of <span class="citation" data-cites="friedman:etal:1997">Friedman, Kohavi, and Yun (<a href="#ref-friedman:etal:1997" role="doc-biblioref">1997</a>)</span> to build local decision trees, called lazy decision trees, and expand it for RF. We also present our attempts at using unidimensional or multidimensional kernels to give more weight to training samples closer to <span class="math inline">x^*</span>.</p>
<section id="sec-lazyDT" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-lazyDT"><span class="header-section-number">3.1</span> Lazy decision trees</h2>
<p>The lazy decision tree algorithm (LazyDT) is introduced in <span class="citation" data-cites="friedman:etal:1997">Friedman, Kohavi, and Yun (<a href="#ref-friedman:etal:1997" role="doc-biblioref">1997</a>)</span>. Its objective is to take into account <span class="math inline">x^*</span> during the tree construction. To do so, the information gain – depending on <span class="math inline">j</span> and <span class="math inline">s</span> – to maximize at each node is modified compared to criterion <a href="#eq-critRF" class="quarto-xref">Equation&nbsp;1</a>. Only the difference of impurity between the mother node <span class="math inline">t</span> and the daughter node where <span class="math inline">x^*</span> ends, denoted <span class="math inline">t^*</span>, is considered. The resulting local information gain is defined by</p>
<p><span id="eq-critLazyDT"><span class="math display">
    G_w(j,s) = I_w(t) - I_w(t^*),
\tag{2}</span></span></p>
<p>where <span class="math inline">I_w</span> is the information gain computed with data at the node, weighted by a weight vector <span class="math inline">w=(w^{(1)}, \ldots, w^{(N)})</span> (described below). Note the absence of the proportion of individuals <span class="math inline">\#t_L/\#t</span> or <span class="math inline">\#t_R/\#t</span> compared to gain <a href="#eq-critRF" class="quarto-xref">Equation&nbsp;1</a>.</p>
<p>To ensure that this gain is always non-negative, to each instance <span class="math inline">(y^{(i)}, x^{(i)})</span> is assigned a weight <span class="math inline">w^{(i)}=\frac{1}{n_k K}</span> when <span class="math inline">y^{(i)}= k</span> and where <span class="math inline">n_k</span> is the number of data labeled <span class="math inline">k</span> at the mother node. Indeed, this weight ensures that all the weighted class frequencies are equal at the mother node, hence the weighted mother node impurity <span class="math inline">I_w(t)</span> is maximal and the resulting gain always non-negative. The value of <span class="math inline">I_w(t)</span> is equal to <span class="math inline">\frac{K-1}{K}</span> for the Gini index, and to <span class="math inline">\log(K)</span> for the entropy. Due to this constant value, the maximization of <a href="#eq-critLazyDT" class="quarto-xref">Equation&nbsp;2</a> is equivalent to the minimization of <span class="math inline">I_w(t^*)</span>. Note that the weights used at <span class="math inline">t^*</span> and <span class="math inline">t</span> are the same (limited to the sub-sample induced by the potential cut depending on <span class="math inline">j</span> and <span class="math inline">s</span> for <span class="math inline">t^*</span>), but are recomputed after each accepted tree partition.</p>
<p>Moreover, those weights also avoid the problem that the impurity measures only use the classes proportions, without distinction of their associated class labels. Indeed, let us take the example of a two-class classification problem (1 and 2), where the mother node contains <span class="math inline">80\%</span> of data labeled 1 and <span class="math inline">20\%</span> labeled 2. A splitting rule computed on unweighted data might induce, at the daughter node where <span class="math inline">x^*</span> falls, <span class="math inline">20\%</span> and <span class="math inline">80\%</span> as proportions of 1 and 2, respectively. In this way, the non-weighted gain <a href="#eq-critLazyDT" class="quarto-xref">Equation&nbsp;2</a> would be zero, even though the discriminatory power of this cut is clearly non-null.</p>
<p>LazyDT provides three other major features: the use of discretised explanatory variables, the use of options and a condition on allowed split events.</p>
<ul>
<li>This algorithm only handles discretised explanatory variables. A preliminary discretisation is thus necessary, using for example the minimum description length principle <span class="citation" data-cites="fayyad:irani:1995">(<a href="#ref-fayyad:irani:1995" role="doc-biblioref">Fayyad and Irani 1995</a>)</span>. This was initially introduced to enhance the algorithm speed. According to our experiments this might also be useful when continuous noise variables are considered as features as splitting along them may result in early strop of the algorithm. For instance in <a href="#fig-early" class="quarto-xref">Figure&nbsp;2</a> below, <span class="math inline">x^*_1</span> is localized at a border of x1 values, together with two datapoints with same label. The next splitting rule will isolate them with <span class="math inline">x^*_1</span> because the resulting node will be pure and hence provide the maximum gain. <span class="math inline">x^*</span> would thus be classified as sky-blue, even though a cut along x2 would have resulted in a purple prediction using many more datapoints. The discretisation will be an asset in such situations since pure noise variables are more likely to be discretised into a unique or few categories containing large amount of data.</li>
<li>The use of <em>options</em> is introduced. Indeed, because features can induce very similar information gains, <span class="citation" data-cites="friedman:etal:1997">Friedman, Kohavi, and Yun (<a href="#ref-friedman:etal:1997" role="doc-biblioref">1997</a>)</span> advise to develop all the paths – induced by splitting rules – achieving at least <span class="math inline">90\%</span> of the maximal possible gain. The prediction associated to a tree for <span class="math inline">x^*</span> becomes the prediction of the leaf with the maximal number of individuals in its majority class. We tried values different from <span class="math inline">90\%</span> and it did not provide better results. Moreover, we studied an alternative to this method of prediction: because each option provides a prediction for <span class="math inline">x^*</span>, we considered taking as final prediction the majority vote of these option predictions, but again results were not more conclusive.</li>
<li>Finally, LazyDT only considers split values that are not equal to the values of <span class="math inline">x^*</span> as potential cuts.</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div id="fig-early" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-early-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-202312-cleynen-local_files/figure-html/fig-early-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-early-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: An illustrative classification problem with 2 classes (purple and sky blye), containing an informative covariate (x2) and a non-informative covariate (x1) and an unlabeled data to classify (black star). Splitting along x1 will result in a pure leaf with sky-blue label.
</figcaption>
</figure>
</div>
</div>
</div>
<p>The LazyDT algorithm has undergone some developments. First, a bagged version to deduce class probabilities is presented in <span class="citation" data-cites="margineantu:dietterich:2003">Margineantu and Dietterich (<a href="#ref-margineantu:dietterich:2003" role="doc-biblioref">2003</a>)</span>. A boosted version is then introduced in <span class="citation" data-cites="fern:etal:2003">Fern and Brodley (<a href="#ref-fern:etal:2003" role="doc-biblioref">2003</a>)</span>. <span class="citation" data-cites="friedman:etal:1997">Friedman, Kohavi, and Yun (<a href="#ref-friedman:etal:1997" role="doc-biblioref">1997</a>)</span> mention as main drawback for this method its inability to allow pruning. <span class="citation" data-cites="fern:etal:2003">Fern and Brodley (<a href="#ref-fern:etal:2003" role="doc-biblioref">2003</a>)</span> propose a heuristic to overcome this drawback, but their algorithm is not guaranteed to improve the classifier accuracy. Considering trees-ensemble overcomes this weakness.</p>
</section>
<section id="sec-localKernel" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-localKernel"><span class="header-section-number">3.2</span> Unidimensional (per covariate) kernel approach</h2>
<p>Most local methods are based on weights depending on the proximity to <span class="math inline">x^*</span>. This is the case of locally weighted regression <span class="citation" data-cites="cleveland:1979 cleveland:devlin:1988 fan:1993 hastie:loader:1993">(<a href="#ref-cleveland:1979" role="doc-biblioref">Cleveland 1979</a>, <a href="#ref-cleveland:devlin:1988" role="doc-biblioref">1988</a>; <a href="#ref-fan:1993" role="doc-biblioref">Fan 1993</a>; <a href="#ref-hastie:loader:1993" role="doc-biblioref">Hastie and Loader 1993</a>)</span>. There are different ways to use weights in the context of tree methods. One can think of taking into account these weights to define the training sets on which trees are built. Such type of strategy is described in <a href="#sec-localWeightingOfIndividuls" class="quarto-xref">Section&nbsp;4</a>. In this section, we examine the possibility of using weights during tree construction, inside the tree splitting criterion.</p>
<p>In the wake of locally weighted regression, we set a weight to each training individual and per covariate <span class="math inline">j</span> depending on its proximity to <span class="math inline">x_j^*</span> in the covariate <span class="math inline">j</span> space. We consider a Gaussian kernel centered in <span class="math inline">x_j^*</span>, providing weights <span class="math display">
K_{h_j}(x_j^{(i)} - x_j^*), \;\; \text{for} \;\; i\in\{1,\ldots,N\}.
</span></p>
<p>We focus on a Gaussian kernel due to its smoothness and to avoid giving exactly zero weights to some individuals, so that <span class="math inline">K_{h_j}(x_j^{(i)} - x_j^*)=1/(\sqrt{2\pi} h_j) \exp\left(-\frac{(x_j^{(i)} - x_j^*)^2}{2h_j^2}\right)</span>.</p>
<p>The choice of the bandwidth <span class="math inline">h_j</span> is tricky. We consider as bandwidth value <span class="math inline">h_j</span> the quantile of order <span class="math inline">\alpha</span> of the distribution of distances to <span class="math inline">x^*</span>: <span class="math inline">\mathbb{Q}_\alpha \left\{ \mid x_j^{(i)} - x_j^*\mid_{i=1, \ldots, N} \right\}</span> (ie <span class="math inline">h_j=d^j_{(\alpha N)}</span> where <span class="math inline">d^j_{(1)},\dots ,d^j_{(N)}</span> are the ordered distances <span class="math inline">\mid x_j^{(i)} - x_j^*\mid</span> of the training data points to <span class="math inline">x^*</span> in the covariate <span class="math inline">j</span> space). The parameter <span class="math inline">\alpha</span> determines the shape of the kernel. For low <span class="math inline">\alpha</span> values, a higher weight is given to data close to <span class="math inline">x^*</span>, and vice-versa. In our numerical experiments, we clearly observed that low values of <span class="math inline">\alpha</span> again result in cuts too close to <span class="math inline">x_j^*</span>. We set <span class="math inline">\alpha=1</span>, i.e.&nbsp;<span class="math inline">h_j</span> is the maximum of the absolute values considered. Moreover, the bandwidth can eventually be recalculated at each internal node or kept constant during the tree construction. We observed very few differences when using a fixed or a varying bandwidth and <span class="math inline">h_j</span> is set as constant in the following.</p>
<p>For a given class label <span class="math inline">k</span>, at the mother node <span class="math inline">t</span>, this approach transforms the usual class frequencies (giving uniform weights among data) into some weighted class frequencies in the following way:</p>
<p><span class="math display">
    p_k  = \frac{\sum_{i:x^{(i)}\in t} \mathbf{1}\{ y^{(i)}=k \}}{\#t} \quad \Rightarrow \quad  \;\;\; \widetilde{p}_{k,j} = \frac{\sum_{i:x^{(i)}\in t} \mathbf{1}\{ y^{(i)}=k \}  K_{h_j}(x_j^{(i)} - x_j^*)}{\sum_{\ell:x^{(\ell)}\in t} K_{h_j}(x_j^{(\ell)} - x_j^*)},
</span></p>
<p>where <span class="math inline">\mathbf{1}\{\cdot\}</span> is the indicator function. Moreover, the proportion of individuals, for example, at the left daughter node <span class="math inline">t_L</span> implied by a cut <span class="math inline">X_j \leq s</span> is transformed from</p>
<p><span id="eq-kernelProp"><span class="math display">
    \frac{\#t_L}{\#t} = \frac{\sum_{i:x^{(i)}\in t} \mathbf{1}\{ x_j^{(i)} \leq s \}}{\#t}
\quad \text{into} \quad
      \frac{\widetilde{\#t_L}}{\widetilde{\#t}} = \frac{\sum_{i:x^{(i)}\in t} \mathbf{1}\{ x_j^{(i)} \leq s \}
K_{h_j}(x_j^{(i)} - x_j^*)}{\sum_{\ell:x^{(\ell)}\in t}
K_{h_j}(x_j^{(\ell)} - x_j^*)}.
\tag{3}</span></span></p>
<p>The information gain to maximize (based on the Gini index) thus becomes</p>
<p><span id="eq-critlocalKernel"><span class="math display">
   \sum_{k=1}^K  \widetilde{p}_{k,j} (1-\widetilde{p}_{k,j})
- \Big(\frac{\widetilde{\#t_L}}{\widetilde{\#t}}  
  \sum_{k=1}^K \widetilde{p}_{k,j}^L (1-\widetilde{p}_{k,j}^L)  
   +\frac{\widetilde{\#t_R}}{\widetilde{\#t}}
    \sum_{k=1}^K \widetilde{p}_{k,j}^R (1-\widetilde{p}_{k,j}^R)
\Big)
\tag{4}</span></span></p>
<p>where <span class="math inline">\widetilde{p}_{k,j}^L</span> and <span class="math inline">\widetilde{p}_{k,j}^R</span> are the weighted proportions of class <span class="math inline">k</span> at the left and right daughter nodes, respectively.</p>
<p><span class="math display">\begin{equation}
\let\scriptstyle\textstyle\substack{\widetilde{I_j}(t)}=\sum_{k=1}^K  \widetilde{p}_{k,j} (1-\widetilde{p}_{k,j})
\end{equation}</span></p>
<p><span class="math display">\begin{equation}
\let\scriptstyle\textstyle\substack{\widetilde{I_j}(t_L)}=\sum_{k=1}^K \widetilde{p}_{k,j}^L (1-\widetilde{p}_{k,j}^L)
\end{equation}</span></p>
<p><span class="math display">\begin{equation}
\let\scriptstyle\textstyle\substack{\widetilde{I_j}(t_R)}=\sum_{k=1}^K \widetilde{p}_{k,j}^R (1-\widetilde{p}_{k,j}^R)
\end{equation}</span></p>
<p>The first term <span class="math inline">\widetilde{I_j}(t)</span> is important and cannot be omitted contrary to the eager version, because it depends on the covariate index.</p>
<p>We use this local Gini index during the tree construction and do not modify the default values for the RF parameters <span class="math inline">m_{\text{try}}</span> and <span class="math inline">N_{\text{min}}</span>. For each tree, the associated prediction is the usual majority vote at the leaf.</p>
<p>Our local splitting rule is similar to the one used in the recent method of <span class="citation" data-cites="armano:tamponi:2018">Armano and Tamponi (<a href="#ref-armano:tamponi:2018" role="doc-biblioref">2018</a>)</span>. In their work, an improvement to RF is introduced by using an ensemble of local trees. Each tree is trained giving more weight to training data around a centroid, which is sampled among the training instances, and different centroids are considered to map the whole predictor space. Although using a local Gini index, this approach is more of an eager one than a local one. Indeed, no test instance is involved during the forest construction. Moreover, a multidimensional kernel per tree is used.</p>
</section>
<section id="sec-localKernelMultiDim" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-localKernelMultiDim"><span class="header-section-number">3.3</span> Multidimensional kernel approach</h2>
<p>In the spirit of <span class="citation" data-cites="armano:tamponi:2018">Armano and Tamponi (<a href="#ref-armano:tamponi:2018" role="doc-biblioref">2018</a>)</span>, it is natural to extend the approach introduced in <a href="#sec-localKernel" class="quarto-xref">Section&nbsp;3.2</a> with a multidimensional kernel centered in <span class="math inline">x^*</span>. We assign to each data <span class="math inline">(y^{(i)},x^{(i)})</span> a weight <span class="math display">
K_V(x^{(i)}-x^*) = 1/(2\pi)^{d/2}\exp{ \left( -\frac{1}{2}(x^{(i)}- x^*)^\top V^{-2} (x^{(i)}- x^*) \right)},
</span> where <span class="math inline">V</span> is a scaling matrix of the Gaussian kernel. Similarly to <a href="#sec-localKernel" class="quarto-xref">Section&nbsp;3.2</a> we consider for <span class="math inline">V</span> the diagonal matrix made of the <span class="math inline">\alpha</span> quantiles, i.e. <span class="math display">
V= \operatorname{diag}\left(\mathbb{Q}_\alpha \left\{ \mid x_1^{(i)}- x_1^* \mid_{i=1, \ldots, N} \right\}, \ldots, \mathbb{Q}_\alpha \left\{ \mid x_d^{(i)}- x_d^*\mid_{i=1, \ldots, N} \right\} \right).
</span> As for the unidimensional kernel approach, using extensive numerical experiments, we observed that low values of <span class="math inline">\alpha</span> result in cuts too close to <span class="math inline">x_j^*</span> and we set <span class="math inline">\alpha=1</span>. Also, the weights are fixed during the tree construction.</p>
<p>The weighted frequency for a given class label <span class="math inline">k</span> becomes</p>
<p><span class="math display">
    \widetilde{p}_k = \frac{\sum_{i=1}^N  \mathbf{1}\{ y^{(i)}=k \}
K_V(x^{(i)}-x^*)}{\sum_{\ell=1}^N K_V(x^{(\ell)}-x^*)}.
</span></p>
<p>The weighted proportions of individual at the daughter nodes are transformed in a similar manner to <a href="#eq-kernelProp" class="quarto-xref">Equation&nbsp;3</a>, resulting in a gain criterion analogous to <a href="#eq-critlocalKernel" class="quarto-xref">Equation&nbsp;4</a>.</p>
<p>The major benefit of such weights is that they do not depend on the covariate index, thus the usual tree prediction, i.e.&nbsp;the majority class at the leaf where <span class="math inline">x^*</span> falls, can be replaced by a more coherent strategy with the tree construction, using as prediction the class with the maximal weighted class proportion at the leaf. Thus, the prediction for <span class="math inline">x^*</span> provided by the <span class="math inline">b</span>-th tree is <span class="math display">
    \hat{y}_b^* = \operatorname{argmax}_{1\leq k \leq K} \widetilde{p}_k.
</span> The forest prediction for <span class="math inline">x^*</span> is the usual majority vote of the tree predictions.</p>
</section>
</section>
<section id="sec-localWeightingOfIndividuls" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Local weighting of individuals</h1>
<p>To avoid the fragmentation problem, instead of modifying the way the predictor space is partitioned, one can consider directly targeting the region of interest, i.e.&nbsp;samples similar to <span class="math inline">x^*</span>. In this part, we focus on strategies acting on the individuals sampling schemes involved at the first step of a tree construction, replacing the usual bootstrap sampling with a local one.</p>
<section id="sec-weightingIndividuals" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-weightingIndividuals"><span class="header-section-number">4.1</span> Weighted bootstrap</h2>
<p><span class="citation" data-cites="xu:etal:2016">Xu, Nettleton, and Nordman (<a href="#ref-xu:etal:2016" role="doc-biblioref">2016</a>)</span> propose to perform weighted bootstrap sampling, where a measure of proximity between <span class="math inline">x^*</span> and the training data is used to compute the weights. This algorithm is entitled Case-Specific Random Forest (CSRF, Algorithm 1).</p>
<p>An individual closer to <span class="math inline">x^*</span> will have higher weight and will more likely be picked in the bootstrap sampling. However, such weights depend heavily on the choice of the proximity measure, especially in a high dimensional setting and with many irrelevant explanatory variables. This is why in this framework the proximity measure will be automatically computed thanks to a bagged tree-ensemble (i.e.&nbsp;with <span class="math inline">m_{\text{try}}=d</span>).</p>
<p>Indeed, for a given tree, <span class="math inline">x^*</span> ends in a leaf with some training data. For each <span class="math inline">x^{(i)}</span>, counting the number of trees where <span class="math inline">x^*</span> and <span class="math inline">x^{(i)}</span> end in the same leaf allows to compute the contribution of <span class="math inline">x^{(i)}</span> to predict <span class="math inline">x^*</span>, denoted <span class="math inline">\omega^{(i)}</span> in Algorithm 1. The deduced weights are then used to perform weighted bootstrap sampling during the training of a new RF. This process can be seen as a nearest neighbors strategy: per tree, a leaf provides a certain amount of neighbors to <span class="math inline">x^*</span>, those are then accumulated over all the trees to deduce instance weights.</p>
<p>This algorithm highly depends on the depth of the first RF trees, hence a pivotal parameter for this strategy is <span class="math inline">N_{\text{min}}</span>, the minimal number of observations at an internal node. The higher <span class="math inline">N_{\text{min}}</span>, the shallower the trees will be. Hence, low values of <span class="math inline">N_{\text{min}}</span> result in putting more weight on the closest individuals to <span class="math inline">x^*</span>, and vice-versa. We tried various values of <span class="math inline">N_{\text{min}}</span> in our experiments, and find that optimal performance require <span class="math inline">Nmin</span> not to be too small.</p>
<hr>
<p><strong>Algorithm 1</strong>: CSRF – local weighting of individuals</p>
<hr>
<p>Step 1. Grow <span class="math inline">B_1</span> bootstrapped trees with <span class="math inline">m_{\text{try}}=d</span> and a given <span class="math inline">N_{\text{min}}</span> value</p>
<p>Step 2. For each training data <span class="math inline">(y^{(i)}, x^{(i)})</span>, count <span class="math inline">c^{(i)}</span> the number of times <span class="math inline">x^{(i)}</span> and <span class="math inline">x^*</span> end in the same leaf</p>
<p>Step 3. Compute the resampling probability of the training individual <span class="math inline">i</span> relative to <span class="math inline">x^*</span> as <span class="math inline">\omega^{(i)}=\frac{c^{(i)}}{\sum_{\ell=1}^N c^{(\ell)}}</span>, for <span class="math inline">i \in \left\{ 1, \ldots, N \right\}</span></p>
<p>Step 4. Train a usual RF of size <span class="math inline">B_2</span> with bootstrap resampling probabilities <span class="math inline">\omega^{(1)}, \ldots, \omega^{(N)}</span> and deduce the prediction for <span class="math inline">x^*</span></p>
<hr>
</section>
<section id="sec-nearest-neighbours" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-nearest-neighbours"><span class="header-section-number">4.2</span> Nearest neighbours: 0/1 weights</h2>
<p>A more intuitive idea is based on the deduction of <span class="math inline">\kappa</span> nearest neighbors (NN) to <span class="math inline">x^*</span>, which are then used to train an RF. <span class="citation" data-cites="fulton:etal:1996">Fulton et al. (<a href="#ref-fulton:etal:1996" role="doc-biblioref">1996</a>)</span> propose several methods to extract data local to <span class="math inline">x^*</span> – the best one being based on NN – in order to build decision trees on this restricted training set. <span class="citation" data-cites="galvan:etal:2009">Galván et al. (<a href="#ref-galvan:etal:2009" role="doc-biblioref">2009</a>)</span> also mention the possibility of pre-selecting closest observations to <span class="math inline">x^*</span> (possibly with replicates) at first and applying any machine learning algorithm on these data set. This kind of strategy is more recently applied in a text classification framework by <span class="citation" data-cites="salles:etal:2018">Salles et al. (<a href="#ref-salles:etal:2018" role="doc-biblioref">2018</a>)</span>, and shows good improvements in terms of classification errors compared to RF (and other ones).</p>
<p>Those approaches are closely related to CSRF (<a href="#sec-weightingIndividuals" class="quarto-xref">Section&nbsp;4.1</a>) since considering NN during a preliminary step is equivalent to giving 0/1 sampling weights (with or without replacement).</p>
<p>In <a href="#sec-examples" class="quarto-xref">Section&nbsp;7</a>, we compare the use of a preliminary selection of nearest neighbors to <span class="math inline">x^*</span> followed by a usual RF training, this strategy is denoted in the remaining by NN-RF, for nearest neighbors - random forest. The main issue of such approaches (and local ones in general) is the difficulty to choose this neighborhood.</p>
</section>
</section>
<section id="sec-weightingCovariates" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Local weighting of covariates</h1>
<p>Instead of acting on the bootstrap resampling of RF, we propose to operate on the covariates subsampling which occurs at each internal node. In the wake of <a href="#sec-weightingIndividuals" class="quarto-xref">Section&nbsp;4.1</a> we propose to weight covariates during the RF trees construction depending on their importance to predict <span class="math inline">x^*</span>. In the following we mention it as LVI-RF (for local variable importance - random forest).</p>
<p>We study the influence of considering sampling probability weights on explanatory variables. The principle is detailed in Algorithm 2 and is very similar to Algorithm 1.</p>
<p>We take profit of a first RF construction with default parameters to deduce covariate importance to predict <span class="math inline">x^*</span>: in a very intuitive way we pass <span class="math inline">x^*</span> through each tree of the RF, and count the number of times each covariate is involved in a splitting rule to allocate <span class="math inline">x^*</span>. We can then easily deduce some predictor weights, and we propose to introduce them into the usual RF covariate sampling, so that a covariate with high weight is more likely to be drawn in the <span class="math inline">m_{\text{try}}</span>-sample.</p>
<p>Our thought is that using such weights might improve the prediction accuracy of the RF, especially in a sparse framework, by avoiding useless data fragmentation according to irrelevant predictors and potential loss of useful training data for the prediction of <span class="math inline">x^*</span>. Moreover, a different set of explanatory variables might be useful to predict different test instances, thus thanks to a local measure of variable importance we also try to ensure that interesting covariates are more likely to be sampled during the tree construction. Finally, in the case of a huge number of noise covariates, even though RF can handle a large number of features, useful ones are very unlikely to be drawn during the tree construction, deteriorating the algorithm performance. In counterpart, weighted covariate sampling might increase the prediction correlation between the RF trees and alter the performance of the global tree ensemble.</p>
<hr>
<p><strong>Algorithm 2</strong>: Local weighting of covariates</p>
<hr>
<p>Step 1. Grow <span class="math inline">B_1</span> randomized trees with <span class="math inline">m_{\text{try}}=\lfloor \sqrt{d} \rfloor</span> and <span class="math inline">N_{\text{min}}=1</span></p>
<p>Step 2. For each covariate <span class="math inline">j \in \left\{ 1, \ldots, d \right\}</span>, count <span class="math inline">v_j</span> the number of times <span class="math inline">X_j</span> has been used during the paths followed by <span class="math inline">x^*</span></p>
<p>Step 3. Compute the resampling probability of the covariate <span class="math inline">j</span> relative to <span class="math inline">x^*</span> as <span class="math inline">p_j=\frac{v_j}{\sum_{\ell=1}^d v_\ell}</span>, for <span class="math inline">j \in \left\{ 1, \ldots, d \right\}</span></p>
<p>Step 4. Train a usual RF of size <span class="math inline">B_2</span> with covariate resampling probabilities <span class="math inline">p_1, \ldots, p_d</span> at each internal node and deduce the prediction for <span class="math inline">x^*</span></p>
<hr>
<p>Some approaches dealing with covariate weighting have been studied in a non-local framework. <span class="citation" data-cites="amaratunga:etal:2008">Amaratunga, Cabrera, and Lee (<a href="#ref-amaratunga:etal:2008" role="doc-biblioref">2008</a>)</span> propose the enriched random forests in an extremely noisy feature space, where covariate sampling is modified using global weights. <span class="citation" data-cites="maudes:etal:2012">Maudes et al. (<a href="#ref-maudes:etal:2012" role="doc-biblioref">2012</a>)</span>, with their random feature weights approach, investigate the use of non-uniform sampling of covariates, changing for each tree.</p>
</section>
<section id="sec-treeWeights" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Local weighting of votes</h1>
<p>The final prediction of a classical RF is the majority vote of all trees, hence they all have equal weight. However a given tree might provide very good predictions on some test instances, but perform very poorly on others. This is why a strategy for building local random forests is based on weighting tree predictions depending on their ability to correctly predict instances similar to <span class="math inline">x^*</span>. Majority vote is hence replaced with locally weighted vote.</p>
<p>In the instance-based framework, <span class="citation" data-cites="robnik:2004">Robnik-Šikonja (<a href="#ref-robnik:2004" role="doc-biblioref">2004</a>)</span>; <span class="citation" data-cites="tsymbal:etal:2006">Tsymbal, Pechenizkiy, and Cunningham (<a href="#ref-tsymbal:etal:2006" role="doc-biblioref">2006</a>)</span> and then <span class="citation" data-cites="zhang:etal:2013">Zhang, Ren, and Suganthan (<a href="#ref-zhang:etal:2013" role="doc-biblioref">2013</a>)</span> investigate this idea. Given a test instance <span class="math inline">x^*</span>, <span class="math inline">\kappa</span> neighbors are selected based on the proximity measure introduced in <span class="citation" data-cites="breiman:2001">Breiman (<a href="#ref-breiman:2001" role="doc-biblioref">2001</a>)</span>, (i.e.&nbsp;the average number of times two data end in the same leaf) to compute a per-tree error score. These scores are further used to select and weight trees and to provide a final weighted-vote prediction.</p>
<section id="sec-dynamicVoting" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="sec-dynamicVoting"><span class="header-section-number">6.1</span> Dynamic voting and selection</h2>
<p>This section describes the methodology of <span class="citation" data-cites="tsymbal:etal:2006">Tsymbal, Pechenizkiy, and Cunningham (<a href="#ref-tsymbal:etal:2006" role="doc-biblioref">2006</a>)</span>, called Dynamic Voting with Selection Random Forest (DVSRF). A first RF is trained thanks to which <span class="math inline">\kappa</span> nearest neighbors to <span class="math inline">x^*</span> are selected. The quality of the <span class="math inline">b</span>-th tree toward <span class="math inline">x^*</span> is then evaluated as the average margins of the out-of-bag <span class="math inline">\kappa</span> instances, weighted by proximities, i.e.&nbsp;</p>
<p><span id="eq-weightsTree"><span class="math display">
    w_b(x^*) = \frac{ \sum_{i=1}^\kappa \mathbf{1}\{x^{(i)}\in \text{OOB}_b\} \, \sigma(x^*, x^{(i)}) \, \text{mr}_b(x^{(i)}) }{\sum_{\ell=1}^\kappa \mathbf{1}\{x^{(\ell)} \in \text{OOB}_b\} \, \sigma(x^*, x^{(\ell)}) } \, ,
\tag{5}</span></span></p>
<p>where <span class="math inline">\text{OOB}_b</span> is the set of out-of-bag data for the <span class="math inline">b</span>-th tree, <span class="math inline">\sigma(x^*, x^{(i)})</span> is the proximity measure provided by the RF, to the power of <span class="math inline">3</span>, and the margin function <span class="math inline">\text{mr}_b(x^{(i)})</span> is equal to <span class="math inline">1</span> if the <span class="math inline">b</span>-th tree predicts <span class="math inline">y^{(i)}</span> correctly, <span class="math inline">-1</span> otherwise. Weights <a href="#eq-weightsTree" class="quarto-xref">Equation&nbsp;5</a> are then normalized to be positive and to sum to one. Finally, the prediction for <span class="math inline">x^*</span> is computed using the majority class of the weighted tree vote proportions</p>
<p><span id="eq-predDVSRF"><span class="math display">
    \hat{y}^* = \operatorname{argmax}_{1\leq k \leq K} p_{\text{DVS},k} \;\;\;\;\;\;
\tag{6}</span></span></p>
<p><span class="math display">
\text{where} \;\;\;\;\;\; p_{\text{DVS},k} = \frac{\sum_{b=1}^B  \mathbf{1}\{ \hat{y}^*_b=k \} w_b(x^*)}{\sum_{\ell=1}^B w_\ell(x^*)}
</span> and <span class="math inline">\hat{y}^*_b</span> denotes the original prediction of the <span class="math inline">b</span>-th tree for <span class="math inline">x^*</span>. \ A predefined number of trees denoted <span class="math inline">B_\text{sel}</span> (usually half of <span class="math inline">B</span>), carrying the highest weights, can be selected and used for the final prediction, modifying weighted predictions <a href="#eq-predDVSRF" class="quarto-xref">Equation&nbsp;6</a> accordingly.</p>
</section>
<section id="sec-kernelVoting" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="sec-kernelVoting"><span class="header-section-number">6.2</span> Kernel weighted voting</h2>
<p>In the same spirit, we investigate the use of a multidimensional kernel as similarity measure (presented in <a href="#sec-localKernelMultiDim" class="quarto-xref">Section&nbsp;3.3</a> and we replace the margin function by the simpler alternative <span class="math inline">\mathbf{1}\{\hat{y}^{(i)}_b=y^{(i)}\}</span> indicating whether the <span class="math inline">b</span>-th tree prediction for <span class="math inline">x^{(i)}</span>, denoted <span class="math inline">\hat{y}^{(i)}_b</span>, is correct or not.</p>
<p>Using the same notations as above, the <span class="math inline">b</span>-th tree weight is hence computed in the following way:</p>
<p><span id="eq-weightsKernelTree"><span class="math display">
w_b(x^*) = \frac{ \sum_{i=1}^N \mathbf{1}\{x^{(i)}\in \text{OOB}_b\} \, K_V(x^{(i)}-x^*) \, \mathbf{1} \{\hat{y}^{(i)}_b=y^{(i)}\} }{\sum_{\ell=1}^N \mathbf{1}\{x^{(\ell)} \in \text{OOB}_b\} \, K_V(x^{(\ell)}-x^*)}.
\tag{7}</span></span></p>
<p>All <span class="math inline">N</span> labeled data are used for the weight computation, their importance being measured by the kernel. <span class="math inline">\alpha</span> is again set to <span class="math inline">1</span> and tree selection is not performed. In the following this proposal is denoted as KV-RF (for kernel voting - random forest).</p>
</section>
</section>
<section id="sec-examples" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Numerical experiments</h1>
<p>In this section, we compare the previously presented methods – summarized below – on two (simulated) Gaussian mixtures examples and a population genetics example.</p>
<ul>
<li>CSRF - Case-specific RF - <a href="#sec-weightingIndividuals" class="quarto-xref">Section&nbsp;4.1</a></li>
<li>NN-RF - Nearest-neighbors RF - <a href="#sec-nearest-neighbours" class="quarto-xref">Section&nbsp;4.2</a></li>
<li>LVI-RF - Local variable importance RF - <a href="#sec-weightingCovariates" class="quarto-xref">Section&nbsp;5</a></li>
<li>DVSRF - Dynamic voting with selection RF - <a href="#sec-dynamicVoting" class="quarto-xref">Section&nbsp;6.1</a></li>
<li>KV-RF - Kernel voting RF - <a href="#sec-kernelVoting" class="quarto-xref">Section&nbsp;6.2</a></li>
</ul>
<p>Methods are run ten times on the same test data set. The average and standard deviation of the ten resulting misclassification error rates, per method, are reported as a measure of performance. Note that in order to recover the predictions for the whole test table, each local algorithm is reapplied to each test data. The first two Gaussian examples have the advantage of being simple enough to compute the Bayes classifier which gives the optimal error rate.</p>
<p>The lazy decision random forest approach presented in <a href="#sec-lazyDT" class="quarto-xref">Section&nbsp;3.1</a> as well as both approaches involving kernels (unidimensional kernels and multidimension kernel presented in <a href="#sec-localKernel" class="quarto-xref">Section&nbsp;3.2</a> and <a href="#sec-localKernelMultiDim" class="quarto-xref">Section&nbsp;3.3</a> were implemented and compared on a lower dimensional simulation study (second Gaussian examples with only 500 test data and 4 replications, results presented in <a href="#sec-gaussianExampleUnbalanced" class="quarto-xref">Section&nbsp;7.2</a> but were dropped of the final comparison due to high computational cost despite poor results. Indeed, localizing trees with identical criterion should be faster, but with modified criterion (information gain or kernel-based Gini criterion), they require the computation of one weight per training data in the leaf, which can be very burdensome. This is particularly true since given our first results, we have not optimized our codes to allow faster computations.</p>
<p>The random forests are built using the default parameters, i.e.&nbsp;trees are maximal (<span class="math inline">N_{\text{min}}=1</span>), and the covariate sampling parameter is <span class="math inline">m_{\text{try}}=\lfloor \sqrt{d} \rfloor</span>. Moreover, each forest is made of <span class="math inline">100</span> trees, meaning CSRF and LVI-RF use a total of <span class="math inline">200</span> trees. Additional/different tuning parameters are specified in the displayed result tables. All the methods involve classic RF, we use the R package <em>ranger</em> <span class="citation" data-cites="wright:ziegler:2017">(<a href="#ref-wright:ziegler:2017" role="doc-biblioref">Wright and Ziegler 2017</a>)</span> for their construction.</p>
<section id="sec-gaussianExample" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="sec-gaussianExample"><span class="header-section-number">7.1</span> Balanced Gaussian mixture example</h2>
<p>We consider 40-dimensional data from four classes <span class="math inline">(1, 2, 3, 4)</span>. The classes have equal weight: <span class="math inline">p_1=p_2=p_3=p_4=1/4</span>. The data are generated from 20-dimensional Gaussian distributions and <span class="math inline">20</span> noise explanatory variables are added, simulated according to a uniform distribution <span class="math inline">\mathcal{U}_{[0;10,000]}</span>. We consider two training data sets of sizes <span class="math inline">3,000</span> and <span class="math inline">10,000</span>, both sampled among the 4 classes with equal probabilities. In both cases, <span class="math inline">5,000</span> simulations are used as testing data set, also sampled equally among the 4 models.</p>
<p>The parameters associated to the <span class="math inline">20</span>-multidimensional Gaussian distribution are <span class="math display">\begin{align*}
    \mu_1 &amp;=    \left(0.8, 3, 1, 2.5,   \ldots,1, 2.5   \right)^\top,       &amp;
    \mu_2 &amp;=    \left(3.2, 3, 2.5, 2.5, \ldots, 2.5, 2.5    \right)^\top,   \\
    \mu_3 &amp;=    \left(2, 1, 2, 2.3, \ldots, 2, 2.3  \right)^\top,           &amp;
    \mu_4 &amp;=    \left(2, 0, 2, 1.8, \ldots, 2, 1.8  \right)^\top,           \\
    \Sigma_1 &amp;= \operatorname{diag}(3, 3, 3, 1, \ldots, 3, 1),        &amp;
    \Sigma_2 &amp;= \operatorname{diag}(3, 3, 3, 5, \ldots, 3, 5),        \\
    \Sigma_3 &amp;= \operatorname{diag}(4, 1, 4, 1, \ldots, 4, 1),        &amp;
    \Sigma_4 &amp;= \operatorname{diag}(2.5, 1, 2.5, 1, \ldots, 2.5, 1).
\end{align*}</span> The first two dimensions are the most relevant for discriminating between the four classes. They are represented in <a href="#fig-gaussEq" class="quarto-xref">Figure&nbsp;3</a>. Indeed, although the remaining ones can provide information to identify the class labels, they are more overlapping with each others and hence less informative. We also consider a higher dimensional setting in which we add <span class="math inline">100</span> additional noise variables (sampled as uniforms on <span class="math inline">[0,1]</span>) for which we reproduce the same training / test combinations. The results are presented in <a href="#tbl-gaussEqNoise10" class="quarto-xref">Table&nbsp;1</a> for <span class="math inline">10,000</span> training data. In both scenarios, using only <span class="math inline">3,000</span> training data increased the error rates of about <span class="math inline">2</span>% for each method, but did not change the comparison.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-gaussEq" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gaussEq-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-202312-cleynen-local_files/figure-html/fig-gaussEq-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gaussEq-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: First Gaussian example: two first explanatory variables <span class="math inline">X_1</span> and <span class="math inline">X_2</span> ; colors indicate the class labels (1-sky blue, 2-purple, 3-sand, 4-dark green).
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div id="tbl-gaussEqNoise10" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-gaussEqNoise10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: First Gaussian example: prediction error rate (percentage), with 10000 training data. With 20 variables (columns 3 and 4), and with 100 additional noise variables (columns 5 and 6)
</figcaption>
<div aria-describedby="tbl-gaussEqNoise10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">Method</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Parameters</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bayes classifier</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">14.638</td>
<td style="text-align: left;">(0.551)</td>
<td style="text-align: left;">14.566</td>
<td style="text-align: left;">(0.285)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Bagged CARTs</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">21.608</td>
<td style="text-align: left;">(0.831)</td>
<td style="text-align: left;">24.154</td>
<td style="text-align: left;">(0.628)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Random forest</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">19.834</td>
<td style="text-align: left;">(0.674)</td>
<td style="text-align: left;">21.638</td>
<td style="text-align: left;">(0.524)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=5</td>
<td style="text-align: left;">22.546</td>
<td style="text-align: left;">(0.639)</td>
<td style="text-align: left;">23.506</td>
<td style="text-align: left;">(0.684)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=10</td>
<td style="text-align: left;">22.638</td>
<td style="text-align: left;">(0.785)</td>
<td style="text-align: left;">23.678</td>
<td style="text-align: left;">(0.762)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=50</td>
<td style="text-align: left;">22.634</td>
<td style="text-align: left;">(0.77)</td>
<td style="text-align: left;">23.648</td>
<td style="text-align: left;">(0.692)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=150</td>
<td style="text-align: left;">22.308</td>
<td style="text-align: left;">(0.679)</td>
<td style="text-align: left;">23.506</td>
<td style="text-align: left;">(0.611)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=250</td>
<td style="text-align: left;">22.302</td>
<td style="text-align: left;">(0.524)</td>
<td style="text-align: left;">23.8</td>
<td style="text-align: left;">(0.78)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=350</td>
<td style="text-align: left;">22.176</td>
<td style="text-align: left;">(0.467)</td>
<td style="text-align: left;">23.838</td>
<td style="text-align: left;">(0.691)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1000</td>
<td style="text-align: left;">18.71</td>
<td style="text-align: left;">(0.537)</td>
<td style="text-align: left;">21.428</td>
<td style="text-align: left;">(0.464)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1500</td>
<td style="text-align: left;">18.718</td>
<td style="text-align: left;">(0.677)</td>
<td style="text-align: left;">20.744</td>
<td style="text-align: left;">(0.679)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=2500</td>
<td style="text-align: left;">19.494</td>
<td style="text-align: left;">(0.845)</td>
<td style="text-align: left;">20.13</td>
<td style="text-align: left;">(0.678)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LVI-RF</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">20.84</td>
<td style="text-align: left;">(0.605)</td>
<td style="text-align: left;">21.634</td>
<td style="text-align: left;">(0.408)</td>
</tr>
<tr class="even">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=100</td>
<td style="text-align: left;">20.018</td>
<td style="text-align: left;">(0.451)</td>
<td style="text-align: left;">22.136</td>
<td style="text-align: left;">(0.466)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=50</td>
<td style="text-align: left;">20.276</td>
<td style="text-align: left;">(0.567)</td>
<td style="text-align: left;">23.286</td>
<td style="text-align: left;">(0.376)</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=1</td>
<td style="text-align: left;">19.81</td>
<td style="text-align: left;">(0.677)</td>
<td style="text-align: left;">21.588</td>
<td style="text-align: left;">(0.443)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.75</td>
<td style="text-align: left;">19.964</td>
<td style="text-align: left;">(0.817)</td>
<td style="text-align: left;">21.612</td>
<td style="text-align: left;">(0.407)</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.5</td>
<td style="text-align: left;">19.86</td>
<td style="text-align: left;">(0.609)</td>
<td style="text-align: left;">22.768</td>
<td style="text-align: left;">(0.402)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.25</td>
<td style="text-align: left;">20.184</td>
<td style="text-align: left;">(0.507)</td>
<td style="text-align: left;">23.356</td>
<td style="text-align: left;">(0.563)</td>
</tr>
</tbody>
</table>


</div>
</div>
</figure>
</div>
</div>
<p>The only method that manages to outbeat a standard random forest is the Nearest-Neighbors RF (about 1% of error rate), while all other methods have similar or worse results than RF.</p>
</section>
<section id="sec-gaussianExampleUnbalanced" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="sec-gaussianExampleUnbalanced"><span class="header-section-number">7.2</span> Unbalanced Gaussian mixture example</h2>
<p>We still consider four classes but their model prior probabilities are <span class="math inline">p_1=p_2=0.4</span> and <span class="math inline">p_3=p_4=0.1</span>. Once again, we considered two training data sets, one made of <span class="math inline">3,000</span> samples, the other of <span class="math inline">10,000</span> samples, drawn among the four classes according to these probabilities. The testing set considers <span class="math inline">5,000</span> data equally sampled among the two classes 3 and 4, the least frequent ones. In this example we therefore measure the prediction accuracy of low-frequency data.</p>
<p>The first two covariates are still the most important ones, however we slightly modified the Gaussian parameters (the first two diagonal terms for <span class="math inline">\Sigma_1</span> and <span class="math inline">\Sigma_2</span> are now 2 and 1) to induce as best split rule for a CART: <span class="math inline">X_1\approx2</span>. This example hence becomes an illustration of the fragmentation problem we mentioned earlier (<a href="#fig-4Unif" class="quarto-xref">Figure&nbsp;1</a>). Indeed, the first cut produced by the eager RF algorithm – if this covariate is sampled – will split the elements labeled 3 and 4 in half (at <span class="math inline">X_1\approx2</span>). It implies the loss of some potentially relevant training data to predict those two classes. We hope local approaches can handle such an example which also contains very unbalanced classes proportions, see <a href="#fig-gaussDisp" class="quarto-xref">Figure&nbsp;4</a>. Once again we also consider the same scenario where we add <span class="math inline">100</span> additional noise variables drawn from uniform distributions on <span class="math inline">[0,1]</span>. The results are presented in <a href="#tbl-gaussUnbNoise10" class="quarto-xref">Table&nbsp;2</a>. Once again, only the results for <span class="math inline">10,000</span> training data are shown as the methods comparison is similar for <span class="math inline">3,000</span> data, at the price of a higher error rate (about 2%).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-gaussDisp" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gaussDisp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-202312-cleynen-local_files/figure-html/fig-gaussDisp-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gaussDisp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Second Gaussian example: two first explanatory variables <span class="math inline">X_1</span> and <span class="math inline">X_2</span> ; colors indicate the classes (1-sky blue, 2-purple, 3-sand, 4-dark green).
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div id="tbl-gaussUnbNoise10" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-gaussUnbNoise10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Second Gaussian example: prediction error rate (percentage), with 10000 training data. With 20 variables (columns 3 and 4), and with 100 additional noise variables (columns 5 and 6)
</figcaption>
<div aria-describedby="tbl-gaussUnbNoise10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">Method</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Parameters</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bayes classifier</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">25.626</td>
<td style="text-align: left;">(0.725)</td>
<td style="text-align: left;">25.53</td>
<td style="text-align: left;">(0.539)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Bagged CARTs</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">39.818</td>
<td style="text-align: left;">(0.882)</td>
<td style="text-align: left;">43.988</td>
<td style="text-align: left;">(1.219)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Random forest</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">40.27</td>
<td style="text-align: left;">(1.249)</td>
<td style="text-align: left;">49.02</td>
<td style="text-align: left;">(1.131)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=5</td>
<td style="text-align: left;">42.35</td>
<td style="text-align: left;">(0.56)</td>
<td style="text-align: left;">46.756</td>
<td style="text-align: left;">(0.948)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=10</td>
<td style="text-align: left;">42.364</td>
<td style="text-align: left;">(0.529)</td>
<td style="text-align: left;">46.724</td>
<td style="text-align: left;">(1.043)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=50</td>
<td style="text-align: left;">41.924</td>
<td style="text-align: left;">(0.504)</td>
<td style="text-align: left;">46.75</td>
<td style="text-align: left;">(0.871)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=150</td>
<td style="text-align: left;">41.52</td>
<td style="text-align: left;">(0.711)</td>
<td style="text-align: left;">46.788</td>
<td style="text-align: left;">(0.957)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=250</td>
<td style="text-align: left;">41.172</td>
<td style="text-align: left;">(0.728)</td>
<td style="text-align: left;">47.074</td>
<td style="text-align: left;">(1.071)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=350</td>
<td style="text-align: left;">40.77</td>
<td style="text-align: left;">(0.862)</td>
<td style="text-align: left;">46.748</td>
<td style="text-align: left;">(0.968)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1000</td>
<td style="text-align: left;">38.26</td>
<td style="text-align: left;">(1.021)</td>
<td style="text-align: left;">50.686</td>
<td style="text-align: left;">(1.185)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1500</td>
<td style="text-align: left;">38.656</td>
<td style="text-align: left;">(1.179)</td>
<td style="text-align: left;">50.116</td>
<td style="text-align: left;">(1.341)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=2500</td>
<td style="text-align: left;">39.012</td>
<td style="text-align: left;">(0.801)</td>
<td style="text-align: left;">49.776</td>
<td style="text-align: left;">(1.239)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LVI-RF</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">42.234</td>
<td style="text-align: left;">(1.271)</td>
<td style="text-align: left;">42.266</td>
<td style="text-align: left;">(0.967)</td>
</tr>
<tr class="even">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=100</td>
<td style="text-align: left;">40.35</td>
<td style="text-align: left;">(1.03)</td>
<td style="text-align: left;">49.362</td>
<td style="text-align: left;">(1.185)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=50</td>
<td style="text-align: left;">40.992</td>
<td style="text-align: left;">(0.966)</td>
<td style="text-align: left;">49.758</td>
<td style="text-align: left;">(1.404)</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=1</td>
<td style="text-align: left;">40.238</td>
<td style="text-align: left;">(1.001)</td>
<td style="text-align: left;">48.78</td>
<td style="text-align: left;">(1.376)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.75</td>
<td style="text-align: left;">39.968</td>
<td style="text-align: left;">(1.17)</td>
<td style="text-align: left;">48.932</td>
<td style="text-align: left;">(1.147)</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.5</td>
<td style="text-align: left;">40.206</td>
<td style="text-align: left;">(1.133)</td>
<td style="text-align: left;">49.304</td>
<td style="text-align: left;">(1.098)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.25</td>
<td style="text-align: left;">40.49</td>
<td style="text-align: left;">(0.987)</td>
<td style="text-align: left;">49.684</td>
<td style="text-align: left;">(0.998)</td>
</tr>
</tbody>
</table>


</div>
</div>
</figure>
</div>
</div>
<p>In this example, when no additional noise is considered, bagging CARTs and Random forest have similar performance, which is once again slightly beaten by a Nearest-neighbors random forest with moderate number of neighbors. When the number of noise variable increases, surprisingly bagging Carts outperforms classic random forest, and is slightly beaten by the Local variable importance RF which manages to select important variables to build trees.</p>
<p>Finally, we performed an independent experiment using the same unbalanced design with noise where we also included a comparison with LazyRF and the univariate and multivariate kernel approach on only 500 test data and 4 replicates. The total experiment took 41 days to run using 10 cores of a standard high performance computing cluster. The results are displayed in <a href="#tbl-Small" class="quarto-xref">Table&nbsp;3</a>. Even though it is hard to compare the results on such small experiments (500 tests hardly cover a 23-dimensional space), there is no clear performance gain for methods LazyRF, Multi-K and Uni-K, who run up to 750 thousand times slower than a classic RF.</p>
<div class="cell">
<div id="tbl-Small" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-Small-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3: Smaller second Gaussian example: prediction error rate for only 500 test data, with runtime comparison
</figcaption>
<div aria-describedby="tbl-Small-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">Method</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Parameters</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">RunTime (seconds)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bagged CARTs</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">46.85</td>
<td style="text-align: left;">(2.542)</td>
<td style="text-align: left;">2.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">Random forest</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">49.65</td>
<td style="text-align: left;">(2.7)</td>
<td style="text-align: left;">0.6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=5</td>
<td style="text-align: left;">48.2</td>
<td style="text-align: left;">(2.546)</td>
<td style="text-align: left;">181.6</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=10</td>
<td style="text-align: left;">47.75</td>
<td style="text-align: left;">(2.484)</td>
<td style="text-align: left;">182.3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=50</td>
<td style="text-align: left;">47.45</td>
<td style="text-align: left;">(2.042)</td>
<td style="text-align: left;">186.6</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=150</td>
<td style="text-align: left;">48.3</td>
<td style="text-align: left;">(1.483)</td>
<td style="text-align: left;">195.6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=250</td>
<td style="text-align: left;">47.85</td>
<td style="text-align: left;">(2.408)</td>
<td style="text-align: left;">203</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=350</td>
<td style="text-align: left;">48.35</td>
<td style="text-align: left;">(1.473)</td>
<td style="text-align: left;">208.1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1000</td>
<td style="text-align: left;">56.35</td>
<td style="text-align: left;">(2.941)</td>
<td style="text-align: left;">26486.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">LVI-RF</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">47.8</td>
<td style="text-align: left;">(2.179)</td>
<td style="text-align: left;">336.8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=100</td>
<td style="text-align: left;">48.55</td>
<td style="text-align: left;">(2.505)</td>
<td style="text-align: left;">6</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=1</td>
<td style="text-align: left;">49.1</td>
<td style="text-align: left;">(2.783)</td>
<td style="text-align: left;">56.1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.75</td>
<td style="text-align: left;">49.85</td>
<td style="text-align: left;">(2.589)</td>
<td style="text-align: left;">58</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.5</td>
<td style="text-align: left;">49.1</td>
<td style="text-align: left;">(1.8)</td>
<td style="text-align: left;">58.5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.25</td>
<td style="text-align: left;">50.65</td>
<td style="text-align: left;">(1.9)</td>
<td style="text-align: left;">58.1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Multi-K</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">49.55</td>
<td style="text-align: left;">(4.129)</td>
<td style="text-align: left;">204851.5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Uni-K</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">50.85</td>
<td style="text-align: left;">(2.462)</td>
<td style="text-align: left;">198210</td>
</tr>
</tbody>
</table>


</div>
</div>
</figure>
</div>
</div>
</section>
<section id="sec-SphereExample" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="sec-SphereExample"><span class="header-section-number">7.3</span> Spherical fragmented example</h2>
<p>We consider an example that combines a fragmentation situation with a spherical data distribution to challenge the splitting rules of standard random forests. Datapoints are drawn from a 3-dimensional Gaussian centered distribution with variance <span class="math inline">4</span> and null covariance. The classes are drawn with uneven probabilities from three labels depending on the location.</p>
<p>For datapoints within a 2.5 distance from the origin:</p>
<ul>
<li><p>if the angle with the first axis is less than 120° in the first 2 dimensions projection [<span class="math inline">(x_1,x_2)</span> projection], the class is 1 with probability 0.8, and 2 and 3 with probability 0.1 ;</p></li>
<li><p>if the angle with the first axis is greater than 240° in the first 2 dimensions projection, it is class 2 with probability 0.8 and 1 or 3 with probability 0.1</p></li>
<li><p>if the angle is between 120° and 240°, and class 3 with probability 0.8, and 1 or 2 with probability 0.1 otherwise.</p></li>
</ul>
<p>If the data point is within a 2.5 to 3.75 distance to the origin, the label class is drawn as previously but considering the <span class="math inline">(x_1,x_3)</span> projections, and if the distance is greater than 3.75 we consider the <span class="math inline">(x_2,x3)</span> projections. An example is illustrated in <a href="#fig-SpherFrag" class="quarto-xref">Figure&nbsp;5</a>.</p>
<p>In this example we performed a slightly different runtime comparison of all methods, conducting the experiment for only one test datapoint and using only one computing node. This allows a fairer comparison between methods which make use of global approaches and those that are entirely local. Results are given as fold-time the runtime of the classic RF, in <a href="#tbl-Spherical" class="quarto-xref">Table&nbsp;4</a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-SpherFrag" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SpherFrag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-202312-cleynen-local_files/figure-html/fig-SpherFrag-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SpherFrag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Spherical fragmented example: two first explanatory variables <span class="math inline">X_1</span> and <span class="math inline">X_2</span> ; colors indicate the class labels (1-sky blue, 2-purple, 3-sand).
</figcaption>
</figure>
</div>
</div>
</div>
<p>In this example, once again bagging CARTs outperforms all other methods, while classic random forests are beaten by almost all other methods except nearest-neighbour Random Forests, who suffer most from the fragmentation issue. Local variable importance RF and Case-specific Random forests perform quite well.</p>
<div class="cell">
<div id="tbl-Spherical" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-Spherical-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4: Spherical fragmented example: prediction error rate (percentage), with 10000 training data, and runtime comparison
</figcaption>
<div aria-describedby="tbl-Spherical-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">Method</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Parameters</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Runtime (fold RF)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bagged CARTs</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">26.408</td>
<td style="text-align: left;">(0.817)</td>
<td style="text-align: left;">5.38</td>
</tr>
<tr class="even">
<td style="text-align: left;">Random forest</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">31.58</td>
<td style="text-align: left;">(0.821)</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=5</td>
<td style="text-align: left;">28.464</td>
<td style="text-align: left;">(0.785)</td>
<td style="text-align: left;">5.68</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=10</td>
<td style="text-align: left;">28.206</td>
<td style="text-align: left;">(0.814)</td>
<td style="text-align: left;">5.58</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=50</td>
<td style="text-align: left;">27.94</td>
<td style="text-align: left;">(0.783)</td>
<td style="text-align: left;">5.22</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=150</td>
<td style="text-align: left;">28.248</td>
<td style="text-align: left;">(0.953)</td>
<td style="text-align: left;">3.98</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=250</td>
<td style="text-align: left;">28.504</td>
<td style="text-align: left;">(0.762)</td>
<td style="text-align: left;">2.94</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=350</td>
<td style="text-align: left;">28.682</td>
<td style="text-align: left;">(0.957)</td>
<td style="text-align: left;">2.35</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1000</td>
<td style="text-align: left;">43.82</td>
<td style="text-align: left;">(1.375)</td>
<td style="text-align: left;">10.35</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1500</td>
<td style="text-align: left;">41.436</td>
<td style="text-align: left;">(1.305)</td>
<td style="text-align: left;">10.39</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=2500</td>
<td style="text-align: left;">38.288</td>
<td style="text-align: left;">(1.155)</td>
<td style="text-align: left;">10.44</td>
</tr>
<tr class="even">
<td style="text-align: left;">LVI-RF</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">27.824</td>
<td style="text-align: left;">(0.666)</td>
<td style="text-align: left;">2.02</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=100</td>
<td style="text-align: left;">30.894</td>
<td style="text-align: left;">(0.808)</td>
<td style="text-align: left;">1.18</td>
</tr>
<tr class="even">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=50</td>
<td style="text-align: left;">30.684</td>
<td style="text-align: left;">(1.039)</td>
<td style="text-align: left;">1.14</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=1</td>
<td style="text-align: left;">31.456</td>
<td style="text-align: left;">(1.088)</td>
<td style="text-align: left;">1.13</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.75</td>
<td style="text-align: left;">31.656</td>
<td style="text-align: left;">(0.886)</td>
<td style="text-align: left;">1.11</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.5</td>
<td style="text-align: left;">31.6</td>
<td style="text-align: left;">(0.876)</td>
<td style="text-align: left;">1.11</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.25</td>
<td style="text-align: left;">32.89</td>
<td style="text-align: left;">(0.825)</td>
<td style="text-align: left;">1.11</td>
</tr>
</tbody>
</table>


</div>
</div>
</figure>
</div>
</div>
</section>
<section id="sec-geneticsExample" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="sec-geneticsExample"><span class="header-section-number">7.4</span> Population genetics example</h2>
<p>We now compare a set of local strategies on a basic population genetics example introduced in <span class="citation" data-cites="pudlo:etal:2016">Pudlo et al. (<a href="#ref-pudlo:etal:2016" role="doc-biblioref">2016</a>)</span>. The historical link between three populations of a given species is of interest. More precisely, we are interested in studying whether a third population emerged from a first or a second population, or whether it emerged from a mixture between the first two. This problem is hence a three classes classification question. The data is made of <span class="math inline">1,000</span> autosomal single-nucleotide polymorphisms (SNPs). We assume that the distances between these loci on the genome are large enough to neglect linkage disequilibrium, we hence consider them as having independent ancestral genealogies.</p>
<p>The data is summarized thanks to <span class="math inline">d=48</span> summary statistics available within the DIY-ABC software for SNP markers <span class="citation" data-cites="cornuet:etal:2014">(<a href="#ref-cornuet:etal:2014" role="doc-biblioref">Cornuet et al. 2014</a>)</span>, which is also used to simulate training and test sets respectively of size <span class="math inline">10,000</span> and <span class="math inline">1,000</span>, equally distributed among the three scenarios. Moreover, the data are constrained to be drawn in the <span class="math inline">[-1;1]^2</span> square on the linear discriminant analysis (LDA) axes projections graph, which is a region where scenarios are hard to discriminate, see <a href="#fig-popGen-LDA" class="quarto-xref">Figure&nbsp;6</a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-popGen-LDA" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-popGen-LDA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Fig4.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-popGen-LDA-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Population genetics example: projections on the LDA axes of the <span class="math inline">10,000</span> training instances ; colors represent scenario indices: sky-blue for model 1, sand for model 2 and purple for model 3 ; the hard to discriminate <span class="math inline">[-1;1]^2</span> region is represented by black dashed lines.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Similarly to the Gaussian mixture examples, the methods are run ten times on the same data. The averaged misclassification error rates and the associated standard deviation are displayed in <a href="#tbl-GenPopResults" class="quarto-xref">Table&nbsp;5</a>.</p>
<p>In this example again, bagging CARTs outperforms a classic random forest. Most local approaches can be tuned to reach a classic RF performance, but none manage to significantly outperform it, let alone reach bagging CARTs results.</p>
<div class="cell">
<div id="tbl-GenPopResults" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-GenPopResults-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;5: Population Genetics example: prediction error rate (percentage), with 10000 training data and 1000 test data
</figcaption>
<div aria-describedby="tbl-GenPopResults-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">Method</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Parameters</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bagged CARTs</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">36.626</td>
<td style="text-align: left;">(0.859)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Random forest</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">38.288</td>
<td style="text-align: left;">(0.935)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=150</td>
<td style="text-align: left;">38.168</td>
<td style="text-align: left;">(0.926)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=250</td>
<td style="text-align: left;">38.078</td>
<td style="text-align: left;">(0.682)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=100</td>
<td style="text-align: left;">38.166</td>
<td style="text-align: left;">(0.78)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1000</td>
<td style="text-align: left;">38.58</td>
<td style="text-align: left;">(0.765)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=1500</td>
<td style="text-align: left;">38.422</td>
<td style="text-align: left;">(0.631)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=2500</td>
<td style="text-align: left;">38.308</td>
<td style="text-align: left;">(0.746)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LVI-RF</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">38.046</td>
<td style="text-align: left;">(1.054)</td>
</tr>
<tr class="even">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=3000,Bsel=50</td>
<td style="text-align: left;">38.616</td>
<td style="text-align: left;">(0.746)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=1</td>
<td style="text-align: left;">37.848</td>
<td style="text-align: left;">(0.766)</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.75</td>
<td style="text-align: left;">38.12</td>
<td style="text-align: left;">(0.764)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.5</td>
<td style="text-align: left;">38.12</td>
<td style="text-align: left;">(0.888)</td>
</tr>
<tr class="even">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;">alpha=0.25</td>
<td style="text-align: left;">38.726</td>
<td style="text-align: left;">(0.662)</td>
</tr>
</tbody>
</table>


</div>
</div>
</figure>
</div>
</div>
</section>
</section>
<section id="sec-reproducibility" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Data accessibility and reproducibility</h1>
<p>The global computational time for the examples presented above represent several days of multiple cores usage and are therefore not directly proposed to the reader. All codes, data and session information are available at <a href="https://github.com/computorg/published-202312-cleynen-local">github.com/computorg/published-202312-cleynen-local</a>. Note that during the preparation of the manuscript we detect an <a href="https://github.com/imbs-hl/ranger/issues/615">issue</a> in the implementation of the Case Specific Random Forests function (csrf) function of the R package ranger and have to redo quite a lot of calculation to ensure reproducibility.</p>
<p>In this section, we reproduce the first Gaussian example presented above (without additional noise) with only 500 training data, 100 test data and 5 replicates, to illustrate the methods and produce similar tables to <a href="#tbl-gaussEqNoise10" class="quarto-xref">Table&nbsp;1</a> to <a href="#tbl-GenPopResults" class="quarto-xref">Table&nbsp;5</a>. The results in themselves are not interpretable due to the low dimensionality of the test and training data, so most methods were only illustrated with one set of parameters. However, changing parameters value in the code is straightforward.</p>
<div class="cell">
<div id="tbl-ToyEx" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-ToyEx-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;6: Toy example: prediction error rate (percentage)
</figcaption>
<div aria-describedby="tbl-ToyEx-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">Method</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Parameters</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">Error rate</th>
<th style="text-align: left;" data-quarto-table-cell-role="th">(sd)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bayes classifier</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">14.6</td>
<td style="text-align: left;">(3.78)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Bagged CARTs</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">29.4</td>
<td style="text-align: left;">(2.07)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Random forest</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">27.4</td>
<td style="text-align: left;">(1.82)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=5</td>
<td style="text-align: left;">29.2</td>
<td style="text-align: left;">(3.35)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CSRF</td>
<td style="text-align: left;">Nmin=10</td>
<td style="text-align: left;">29.6</td>
<td style="text-align: left;">(3.21)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NN-RF</td>
<td style="text-align: left;">k=250</td>
<td style="text-align: left;">26.8</td>
<td style="text-align: left;">(4.32)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LVI-RF</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">28.2</td>
<td style="text-align: left;">(5.45)</td>
</tr>
<tr class="even">
<td style="text-align: left;">DVSRF</td>
<td style="text-align: left;">k=100,Bsel=100</td>
<td style="text-align: left;">25.2</td>
<td style="text-align: left;">(1.64)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">KV-RF</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">25</td>
<td style="text-align: left;">(2.55)</td>
</tr>
</tbody>
</table>


</div>
</div>
</figure>
</div>
</div>
</section>
<section id="sec-discussions" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Discussions</h1>
<p>In this paper, we review, discuss and propose local tree-based methods strategies taking into account a specific instance during the learning process in the context of classification problems. The results are not up to our expectations. We considered four examples where local methods seemed useful but we did not obtained conclusive results.</p>
<p>Our proposal to introduce weights in the splitting criterion (see <a href="#sec-localSplittingRules" class="quarto-xref">Section&nbsp;3</a>): LazyDT and kernel approaches) is problematic. Putting too high weights around <span class="math inline">x^*</span> results in irrelevant cut-points, closer to <span class="math inline">x^*</span> compared to RF. It induces large correlations between the trees in the forest, and the quality of prediction is impacted negatively. This is why for the kernel approaches a bandwith of quantile <span class="math inline">\alpha=1</span> is preferred. With this choice, even if it localized the trees, we obtained results very similar if not worse than those of RF, at the cost of very high computational complexity. Less computationally intensive but as disappointing is the kernel voting RF strategy.</p>
<p>The CSRF of <span class="citation" data-cites="xu:etal:2016">Xu, Nettleton, and Nordman (<a href="#ref-xu:etal:2016" role="doc-biblioref">2016</a>)</span> (see <a href="#sec-weightingIndividuals" class="quarto-xref">Section&nbsp;4.1</a>), the nearest neighbor weights (<a href="#sec-nearest-neighbours" class="quarto-xref">Section&nbsp;4.2</a>) and the local weighting of covariates (<a href="#sec-weightingCovariates" class="quarto-xref">Section&nbsp;5</a>) strategies can give good performance but depend on tuning parameters. For instance, the CSRF brings better performance when the tree depth is low, i.e.&nbsp;high <span class="math inline">N_{\text{min}}</span>. However, generally, results provided by these local methods are very similar to eager ones, and no great benefit is observed on our three examples. When looking at the very small benefits in terms of prediction error rate compared to the non-local approaches, we can say that local strategies are clearly not worth the additional computational cost. Especially since most of them require the choice of a tuning parameter, characterizing the weights given to instances surrounding <span class="math inline">x^*</span>.</p>
<p>We have not considered here the case of regression problems, for which local tree-based methods have also been proposed. For instance the CSRF, the nearest neighbor weights and the dynamic voting with selection random forests are directly applicable to regression forests, and in most cases already implemented. Similarly, our propositions regarding local weighting of covariates, and local splitting criterion using kernels would easily be extendable to regression problems. In a local regression framework, <span class="citation" data-cites="friedberg2020local">Friedberg et al. (<a href="#ref-friedberg2020local" role="doc-biblioref">2020</a>)</span> consider a two-step approach where the response <span class="math inline">y^\star</span> is predicted from a locally weighted ridge regression using weights from a modified random forest. This forest is built with a modified splitting criterion which minimizes the residuals in each leaf after fitting a ridge regression to predict <span class="math inline">y_j</span> from <span class="math inline">x_j</span>. Whether these methods improve the original random forest in the case of regression is still an open question, but our results in the case of classification are not optimistic.</p>
</section>
<section id="acknowledgements" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> Acknowledgements</h1>
<p>We thank the referees for their very helpful suggestions, helping us to improve the quality of that paper. We also express gratitude to the Associate Editor Nelle Varoquaux and the Editor Julien Chiquet for dedicating their time to this paper and for their responses to our numerous inquiries about the tools.</p>
</section>
<section id="funding" class="level1" data-number="11">
<h1 data-number="11"><span class="header-section-number">11</span> Funding</h1>
<p>This work was supported by the French National Research Agency (ANR) through the project ANR-18-CE40-0034 (ABSint).</p>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-aha:etal:1991" class="csl-entry" role="listitem">
Aha, D. W., D. Kibler, and M. K. Albert. 1991. <span>“<span class="nocase">Instance-based learning algorithms</span>.”</span> <em>Machine Learning</em> 6: 37–66.
</div>
<div id="ref-amaratunga:etal:2008" class="csl-entry" role="listitem">
Amaratunga, D., J. Cabrera, and Y.-S. Lee. 2008. <span>“Enriched Random Forests.”</span> <em>Bioinformatics</em> 24 (18): 2010–14.
</div>
<div id="ref-armano:tamponi:2018" class="csl-entry" role="listitem">
Armano, G., and E. Tamponi. 2018. <span>“Building Forests of Local Trees.”</span> <em>Pattern Recognition</em> 76: 380–90.
</div>
<div id="ref-beaumont:etal:2002" class="csl-entry" role="listitem">
Beaumont, M., W. Zhang, and D. Balding. 2002. <span>“Approximate <span>Bayesian</span> Computation in Population Genetics.”</span> <em>Genetics</em> 162 (4): 2025–35.
</div>
<div id="ref-biau:2012" class="csl-entry" role="listitem">
Biau, G. 2012. <span>“Analysis of a Random Forest Model.”</span> <em>Journal of Machine Learning Research</em> 13: 1063–95.
</div>
<div id="ref-blum:francois:2010" class="csl-entry" role="listitem">
Blum, M. G. B., and O. François. 2010. <span>“Non-Linear Regression Models for Approximate <span>B</span>ayesian Computation.”</span> <em>Statistics and Computing</em> 20: 63–73.
</div>
<div id="ref-blum:etal:2013" class="csl-entry" role="listitem">
Blum, M. G. B., M. Nunes, D. Prangle, and S. A. Sisson. 2013. <span>“A Comparative Review of Dimension Reduction Methods in Approximate <span>Bayesian</span> Computation.”</span> <em>Statistical Science</em> 28 (2): 189–208.
</div>
<div id="ref-breiman:1996" class="csl-entry" role="listitem">
Breiman. 1996. <span>“Bagging Predictors.”</span> <em>Machine Learning</em> 24: 123–40.
</div>
<div id="ref-breiman:2001" class="csl-entry" role="listitem">
———. 2001. <span>“Random Forests.”</span> <em>Machine Learning</em> 45: 5–32.
</div>
<div id="ref-breiman:etal:1984" class="csl-entry" role="listitem">
Breiman, L., J. Friedman, C. J. Stone, and R. A. Olshen. 1984. <em>Classification and Regression Trees</em>. The Wadsworth and Brooks-Cole Statistics-Probability Series. Taylor &amp; Francis.
</div>
<div id="ref-chapelle:etal:2010" class="csl-entry" role="listitem">
Chapelle, O., B. Schölkopf, and A. Zien. 2010. <em>Semi-Supervised Learning</em>. Adaptive Computation and Machine Learning. MIT Press.
</div>
<div id="ref-cleveland:1979" class="csl-entry" role="listitem">
Cleveland, W. 1979. <span>“<span class="nocase">Robust Locally Weighted Regression and Smoothing Scatterplots</span>.”</span> <em>Journal of the American Statistical Association</em> 74 (368): 829–36.
</div>
<div id="ref-cleveland:devlin:1988" class="csl-entry" role="listitem">
———. 1988. <span>“<span class="nocase">Locally Weighted Regression: An Approach to Regression Analysis by Local Fitting</span>.”</span> <em>Journal of the American Statistical Association</em> 83 (403): 596–610.
</div>
<div id="ref-cornuet:etal:2014" class="csl-entry" role="listitem">
Cornuet, J.-M., P. Pudlo, J. Veyssier, A. Dehne-Garcia, M. Gautier, R. Leblois, J.-M. Marin, and A. Estoup. 2014. <span>“DIYABC V2.0: A Software to Make Approximate Bayesian Computation Inferences about Population History Using Single Nucleotide Polymorphism, <span>DNA</span> Sequence and Microsatellite Data.”</span> <em>Bioinformatics</em> 30 (8): 1187–89.
</div>
<div id="ref-fan:1993" class="csl-entry" role="listitem">
Fan, J. 1993. <span>“Local Linear Regression Smoothers and Their Minimax Efficiencies.”</span> <em>The Annals of Statistics</em> 21 (1): 196?216.
</div>
<div id="ref-fayyad:irani:1995" class="csl-entry" role="listitem">
Fayyad, U. M., and K. B. Irani. 1995. <span>“Multi-Interval Discretization of Continuous-Valued Attributes for Classification Learning.”</span> <em>Proceedings of the 13th International Joint Conference on Artificial Intelligence</em> 2: 1022–27.
</div>
<div id="ref-fern:etal:2003" class="csl-entry" role="listitem">
Fern, X. Z, and C. E Brodley. 2003. <span>“Boosting Lazy Decision Trees.”</span> <em>Proceedings of the Twentieth International Conference on Machine Learning</em> 20 (1): 178–85.
</div>
<div id="ref-friedberg2020local" class="csl-entry" role="listitem">
Friedberg, Rina, Julie Tibshirani, Susan Athey, and Stefan Wager. 2020. <span>“Local Linear Forests.”</span> <em>Journal of Computational and Graphical Statistics</em> 30 (2): 503–17.
</div>
<div id="ref-friedman:etal:1997" class="csl-entry" role="listitem">
Friedman, J. H., R. Kohavi, and Y. Yun. 1997. <span>“Lazy Decision Trees.”</span> <em>Proceedings of the 13th National Conference on AAAI</em>, 717–24.
</div>
<div id="ref-fulton:etal:1996" class="csl-entry" role="listitem">
Fulton, T., S. Kasif, S. Salzberg, and D. L. Waltz. 1996. <span>“Local Induction of Decision Trees: Towards Interactive Data Mining.”</span> In <em>Proceedings of the Second International Conference on Knowledge Discovery and Data Mining</em>, 14–19. AAAI Press.
</div>
<div id="ref-galvan:etal:2009" class="csl-entry" role="listitem">
Galván, I. M., J. M. Valls, N. Lecomte, and P. Isasi. 2009. <span>“A Lazy Approach for Machine Learning Algorithms.”</span> <em>IFIP International Federation for Information Processing</em> 296: 517–22.
</div>
<div id="ref-gammerman:etal:1998" class="csl-entry" role="listitem">
Gammerman, A., V. Vovk, and V. Vapnik. 1998. <span>“Learning by Transduction.”</span> In <em>Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intelligence</em>, 148–55. UAI’98. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc.
</div>
<div id="ref-hastie:loader:1993" class="csl-entry" role="listitem">
Hastie, T., and C. Loader. 1993. <span>“Local Regression: Automatic Kernel Carpentry (with Discussion).”</span> <em>Statistical Science</em> 8 (2): 120–29.
</div>
<div id="ref-margineantu:dietterich:2003" class="csl-entry" role="listitem">
Margineantu, D. D., and T. G. Dietterich. 2003. <span>“Improved Class Probability Estimates from Decision Tree Models.”</span> <em>Lecture Notes in Statistics - Nonlinear Estimation and Classification</em> 171: 173–88.
</div>
<div id="ref-maudes:etal:2012" class="csl-entry" role="listitem">
Maudes, J., J. J. Rodríguez, C. Carcía-Osorio, and N. Garcá-Pedrajas. 2012. <span>“<span>R</span>andom Feature Weights for Decision Tree Ensemble Construction.”</span> <em>Information Fusion</em> 13 (1): 20–30.
</div>
<div id="ref-pritchard:etal:1999" class="csl-entry" role="listitem">
Pritchard, J. K., M. T. Seielstad, A. Perez-Lezaun, and M. W. Feldman. 1999. <span>“Population Growth of Human <span>Y</span> Chromosomes: A Study of <span>Y</span> Chromosome Microsatellites.”</span> <em>Molecular Biology and Evolution</em> 16: 1791–98.
</div>
<div id="ref-pudlo:etal:2016" class="csl-entry" role="listitem">
Pudlo, P., J.-M. Marin, A. Estoup, J.-M. Cornuet, M. Gautier, and C. P. Robert. 2016. <span>“Reliable <span>ABC</span> Model Choice via Random Forests.”</span> <em>Bioinformatics</em> 32 (6): 859–66.
</div>
<div id="ref-raynal:etal:2019" class="csl-entry" role="listitem">
Raynal, L., J.-M. Marin, P. Pudlo, M. Ribatet, C. P. Robert, and A. Estoup. 2019. <span>“<span>ABC</span> Random Forests for <span>B</span>ayesian Parameter Inference.”</span> <em>Bioinformatics</em> 35 (10): 1720–28.
</div>
<div id="ref-robnik:2004" class="csl-entry" role="listitem">
Robnik-Šikonja, M. 2004. <span>“Improving Random Forests.”</span> In <em>Machine Learning: ECML 2004</em>, edited by Jean-François Boulicaut, Floriana Esposito, Fosca Giannotti, and Dino Pedreschi, 359–70. Berlin, Heidelberg: Springer Berlin, Heidelberg.
</div>
<div id="ref-salles:etal:2018" class="csl-entry" role="listitem">
Salles, T., M. Gonçalves, V. Rodrigues, and L. Rocha. 2018. <span>“Improving Random Forests by Neighborhood Projection for Effective Text Classification.”</span> <em>Information Systems</em> 77: 1–21.
</div>
<div id="ref-scornet:etal:2015" class="csl-entry" role="listitem">
Scornet, E., G. Biau, and J.-P. Vert. 2015. <span>“Consistency of Random Forests.”</span> <em>Annals of Statistics</em> 43 (4): 1716–41.
</div>
<div id="ref-tavare:etal:1997" class="csl-entry" role="listitem">
Tavaré, S., D. Balding, R. Griffiths, and P. Donnelly. 1997. <span>“Inferring Coalescence Times from DNA Sequence Data.”</span> <em>Genetics</em> 145 (2): 505–18.
</div>
<div id="ref-tsymbal:etal:2006" class="csl-entry" role="listitem">
Tsymbal, A., M. Pechenizkiy, and Pádraig Cunningham. 2006. <span>“Dynamic Integration with Random Forests.”</span> In <em>Machine Learning: ECML 2006. ECML 2006. Lecture Notes in Computer Science</em>, edited by J. Fürnkranz, T. Scheffer, and M. Spiliopoulou, 801–8. Berlin, Heidelberg: Springer Berlin, Heidelberg.
</div>
<div id="ref-wright:ziegler:2017" class="csl-entry" role="listitem">
Wright, M. N., and A. Ziegler. 2017. <span>“Ranger: A Fast Implementation of Random Forests for High Dimensional Data in <span>C</span>++ and <span>R</span>.”</span> <em>Journal of Statistical Software</em> 77 (1): 1–17.
</div>
<div id="ref-xu:etal:2016" class="csl-entry" role="listitem">
Xu, R., D. Nettleton, and D. J. Nordman. 2016. <span>“Case-Specific Random Forests.”</span> <em>Journal of Computational and Graphical Statistics</em> 25 (1): 49–65.
</div>
<div id="ref-zhang:etal:2013" class="csl-entry" role="listitem">
Zhang, L., Y. Ren, and P. N. Suganthan. 2013. <span>“Instance Based Random Forest with Rotated Feature Space.”</span> In <em>2013 IEEE Symposium on Computational Intelligence and Ensemble Learning (CIEL)</em>, 31–35.
</div>
</div>
</section>


<div id="quarto-appendix" class="default"><section id="session-information" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Session information</h2><div class="quarto-appendix-contents">

<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.3.1 (2023-06-16)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 22.04.3 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 
LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0

locale:
 [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       
 [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   
 [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          
[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   

time zone: UTC
tzcode source: system (glibc)

attached base packages:
[1] parallel  stats     graphics  grDevices datasets  utils     methods  
[8] base     

other attached packages:
[1] Rcpp_1.0.11   ranger_0.16.0 xtable_1.8-4  mvtnorm_1.2-3

loaded via a namespace (and not attached):
 [1] httr_1.4.7        svglite_2.1.1     cli_3.6.1         knitr_1.43       
 [5] rlang_1.1.1       xfun_0.40         highr_0.10        stringi_1.7.12   
 [9] renv_1.0.2        jsonlite_1.8.7    glue_1.6.2        colorspace_2.1-0 
[13] htmltools_0.5.6   scales_1.2.1      rmarkdown_2.25    grid_4.3.1       
[17] evaluate_0.21     munsell_0.5.0     kableExtra_1.3.4  fastmap_1.1.1    
[21] yaml_2.3.7        lifecycle_1.0.3   stringr_1.5.0     compiler_4.3.1   
[25] rvest_1.0.3       rstudioapi_0.15.0 lattice_0.22-5    systemfonts_1.0.4
[29] digest_0.6.33     viridisLite_0.4.2 R6_2.5.1          magrittr_2.0.3   
[33] Matrix_1.6-1      webshot_0.5.5     tools_4.3.1       xml2_1.3.5       </code></pre>
</div>
</div>
<!-- -->

</div></section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{cleynen2023,
  author = {Cleynen, Alice and Raynal, Louis and Marin, Jean-Michel},
  publisher = {French Statistical Society},
  title = {Local Tree Methods for Classification: A Review and Some Dead
    Ends},
  journal = {Computo},
  date = {2023-12-14},
  url = {https://computo.sfds.asso.fr/published-202312-cleynen-local/},
  doi = {10.57750/3j8m-8d57},
  issn = {2824-7795},
  langid = {en},
  abstract = {Random Forests (RF) {[}@breiman:2001{]} are very popular
    machine learning methods. They perform well even with little or no
    tuning, and have some theoretical guarantees, especially for sparse
    problems {[}@biau:2012;@scornet:etal:2015{]}. These learning
    strategies have been used in several contexts, also outside the
    field of classification and regression. To perform Bayesian model
    selection in the case of intractable likelihoods, the ABC Random
    Forests (ABC-RF) strategy of @pudlo:etal:2016 consists in applying
    Random Forests on training sets composed of simulations coming from
    the Bayesian generative models. The ABC-RF technique is based on an
    underlying RF for which the training and prediction phases are
    separated. The training phase does not take into account the data to
    be predicted. This seems to be suboptimal as in the ABC framework
    only one observation is of interest for the prediction. In this
    paper, we study tree-based methods that are built to predict a
    specific instance in a classification setting. This type of methods
    falls within the scope of local (lazy/instance-based/case specific)
    classification learning. We review some existing strategies and
    propose two new ones. The first consists in modifying the tree
    splitting rule by using kernels, the second in using a first RF to
    compute some local variable importance that is used to train a
    second, more local, RF. Unfortunately, these approaches, although
    interesting, do not provide conclusive results.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-cleynen2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Cleynen, Alice, Louis Raynal, and Jean-Michel Marin. 2023. <span>“Local
Tree Methods for Classification: A Review and Some Dead Ends.”</span>
<em>Computo</em>, December. <a href="https://doi.org/10.57750/3j8m-8d57">https://doi.org/10.57750/3j8m-8d57</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb3" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Local tree methods for classification: a review and some dead ends"</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Alice Cleynen</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    email: alice.cleynen@umontpellier.fr</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://alice.cleynen.fr/</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0001-8083-0204</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: IMAG, Univ Montpellier, CNRS, UMR 5149, Montpellier, France</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://imag.umontpellier.fr/</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Louis Raynal</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">    email: louis.raynal@chd-vendee.fr</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0003-2805-3254</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Centre Hospitalier Départemental Vendée, La Roche-sur-Yon, France</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">      - url: https://www.chd-vendee.fr/</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Jean-Michel Marin</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">    email: jean-michel.marin@umontpellier.fr</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://imag.umontpellier.fr/~marin/</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0001-7451-9719</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: IMAG, Univ Montpellier, CNRS, UMR 5149, Montpellier, France</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://imag.umontpellier.fr/</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 12/14/2023</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co">    Random Forests (RF) [@breiman:2001] are very popular machine learning methods. They perform well even with little or no tuning, and have some theoretical guarantees, especially for sparse problems [@biau:2012;@scornet:etal:2015]. These learning strategies have been used in several contexts, also outside the field of classification and regression. To perform Bayesian model selection in the case of intractable likelihoods, the ABC Random Forests (ABC-RF) strategy of @pudlo:etal:2016 consists in applying Random Forests on training sets composed of simulations coming from the Bayesian generative models. The ABC-RF technique is based on an underlying RF for which the training and prediction phases are separated. The training phase does not take into account the data to be predicted. This seems to be suboptimal as in the ABC framework only one observation is of interest for the prediction. In this paper, we study tree-based methods that are built to predict a specific instance in a classification setting. This type of methods falls within the scope of local (lazy/instance-based/case specific) classification learning. We review some existing strategies and propose two new ones. The first consists in modifying the tree splitting rule by using kernels, the second in using a first RF to compute some local variable importance that is used to train a second, more local, RF. Unfortunately, these approaches, although interesting, do not provide conclusive results.</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [classification, Random Forests, local methods]</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "10.57750/3j8m-8d57"</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "French Statistical Society"</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="co">  pdf-url: "https://computo.sfds.asso.fr/published-202312-cleynen-local/published-202312-cleynen-local.pdf"</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co">  url:  "https://computo.sfds.asso.fr/published-202312-cleynen-local/"</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="an">google-scholar:</span><span class="co"> true  </span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "published-202312-cleynen-local"</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> false # set to false once the build is running</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> true # will be set to true once accepted</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>::: {.content-hidden unless-format="html"}</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>$\newcommand{\diag}{\operatorname{diag}}$</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>$\newcommand{\var}{\mathrm{Var}}$</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>$\newcommand{\xs}{x^*}$</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>$\newcommand{\xsj}{x_j^*}$</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>$\newcommand{\xsij}{x_j^{*(i)}}$</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>$\newcommand{\inroot}{\in\text{ROOT}}$</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>$\newcommand{\idxi}{^{(i)}}$</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>$\newcommand{\Nmin}{N_{\text{min}}}$</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>$\newcommand{\mtry}{m_{\text{try}}}$</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>$\newcommand{\indicator}{\mathds{1}}$</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>$\renewcommand{\P}{\mathbb{P}}$</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>::: {.content-hidden unless-format="pdf"}</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>\newcommand{\argmax}{\operatorname{argmax}}</span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>\newcommand{\diag}{\operatorname{diag}}</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>\newcommand{\var}{\mathrm{Var}}</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>\newcommand{\xs}{x^*}</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>\newcommand{\xsj}{x_j^*}</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>\newcommand{\xsij}{x_j^{*(i)}}</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>\newcommand{\inroot}{\in\text{ROOT}}</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>\newcommand{\idxi}{^{(i)}}</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>\newcommand{\Nmin}{N_{\text{min}}}</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>\newcommand{\mtry}{m_{\text{try}}}</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>\newcommand{\indicator}{\mathds{1}}</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>\renewcommand{\P}{\mathbb{P}}</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>The machine learning field of local/lazy/instance-based/case-specific learning <span class="co">[</span><span class="ot">@aha:etal:1991</span><span class="co">]</span> aims at taking into account a particular instance $\xs$ to produce a prediction thanks to its similarity to the training data set.</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>It is opposed to eager learning, where the prediction is divided in two parts: a training phase where a global model is fitted and then a prediction phase. The local approach, in contrast, fits a model taking into account the information provided by $\xs$.</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>Two closely related learning fields need to be mentioned: semi-supervised learning <span class="co">[</span><span class="ot">@chapelle:etal:2010</span><span class="co">]</span> and transductive learning <span class="co">[</span><span class="ot">@gammerman:etal:1998</span><span class="co">]</span>. Semi-supervised learning introduces unlabeled data (whose response is unknown) in addition to labeled ones to build a general model within the training phase. Then, in the testing phase this model is used to predict the response value of a new unlabeled data (different from the first ones). Transductive learning takes profit of a set of labeled and unlabelled data to avoid the construction of a general model and directly predicts the response values of those same unlabeled data. To our knowledge, semi-supervised and transductive learning require a high number of test/unlabeled instances. In our case only one is provided, making those approaches unsuitable. </span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>The main drawback of local learning approaches is their high computational cost, because for each new test data a model has to be constructed. However, it can be very useful in domains where only one test instance is provided.</span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>Approximate Bayesian computation (ABC, @tavare:etal:1997; @pritchard:etal:1999) is a statistical method developed for frameworks where the likelihood is intractable. It relies on simulations according to Bayesian hierarchical models to generate pseudo-data. These artificial data are then compared to the test/observed one. To this effect    , the most basic algorithm is based on nearest neighbors (NN). Recently, @breiman:2001's machine learning algorithm of random forests (RF) proved to bring a meaningful improvement to the ABC paradigm in both a context of model choice <span class="co">[</span><span class="ot">@pudlo:etal:2016</span><span class="co">]</span> and parameter inference <span class="co">[</span><span class="ot">@raynal:etal:2019</span><span class="co">]</span>. </span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>Here, we focus on the model choice problem and thus the classification setting.</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>Unlike some ABC techniques that take advantage of local methods, such as local adjustment <span class="co">[</span><span class="ot">@beaumont:etal:2002; @blum:francois:2010; @blum:etal:2013</span><span class="co">]</span>, ABC-RF trains an eager RF to predict, later on, the observed data.</span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>It seems sub-optimal because in the ABC framework only the observed data is of interest for prediction.</span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>The ABC-RF strategy might therefore greatly benefit from local versions of RF.</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>Here, we focus on reviewing and proposing tree-based method to predict at best a specific data of interest.</span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>We start with some reminders on @breiman:2001's RF algorithm. We then study local tree-based approaches depending </span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>on the way the localization process is performed. In </span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>@sec-localSplittingRules, we  introduce internal modifications </span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>of the RF concerning the splitting rule. Then, we take an interest on modifying the random aspects of RF to turn them into local ones. </span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>We focus on modifying the sampling of individuals in</span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a>@sec-localWeightingOfIndividuls, and the sampling of predictors in</span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>@sec-weightingCovariates. Local weighting of votes is finally presented in</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>@sec-treeWeights.</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>We empirically compare these strategies with the original, eager one in four examples where a local approach might be of interest.</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a><span class="fu"># Reminders on Breiman's random forest {#sec-recallsRF}</span></span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>In the following we consider a classification problem.</span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>We use a set of $d$ explanatory variables $X=(X_1, \ldots, X_d)$ to predict </span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>the categorical/discrete response $Y$ belonging to $<span class="sc">\{</span>1,\dots,K<span class="sc">\}</span>$.. </span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>The training data set is composed of $N$ realizations </span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>$\big<span class="sc">\{</span> (y\idxi, x\idxi) \big<span class="sc">\}</span>_{i=1,\ldots,N}$.</span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>We consider @breiman:2001's random forest as the reference method to improve.</span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>An RF is a set of randomized trees <span class="co">[</span><span class="ot">@breiman:etal:1984</span><span class="co">]</span>, each one partitioning the covariates space thanks to a series of allocation rules and assigning a class label as prediction to each partition.</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>A binary tree is composed of internal and terminal nodes (a.k.a. leaves).</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>For each internal node, a splitting rule on an explanatory variable is determined by maximizing an information gain, dividing the training set in two parts. This process is recursively iterated until a stopping rule is achieved. The internal node encountering a stopping rule becomes terminal.</span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>For continuous covariates, a splitting rule compares a covariate $X_j$ to a bound $s$, allocating to the left branch the data verifying the rule $X_j \leq s$, and to the right all others.</span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>For categorical covariates, the splitting rule is chosen among all the possible two-way splits of the covariate categories.</span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>The covariate index $j$ and the bound $s$ are chosen to maximize the decrease of impurity between the mother, denoted $t$, and the two resulting left and right daughter nodes, denoted $t_L$ and $t_R$, (weighted by the number of data at each node). This gain associated to a covariate $j$ and split value $s$ is always non negative and is written as</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>    G(j,s) = I(t) - \left( \frac{<span class="sc">\#</span>t_L}{<span class="sc">\#</span>t} I(t_L) + \frac{<span class="sc">\#</span>t_R}{<span class="sc">\#</span>t} I(t_R) \right), </span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>$${#eq-critRF}</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>where $<span class="sc">\#</span>$ refers to the number of data in the associated node, and $I(\cdot)$ is the impurity.</span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>The impurity, i.e. the heterogeneity at a given node, is measured with either the Gini index or the entropy. </span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>The Gini index, defined for categorical variables as $\sum_{k=1}^K p_k(1-p_k)$, is less computationally intensive as is counterpart, the entropy, defined as  $\sum_{k=1}^K p_k\log(p_k)$ which gives slightly better results. In both cases, the objective is to select the allocation rule that reduces the impurity the most, in other terms that produces the highest gain.</span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>Splitting events stop when one of the three following situation is reached:</span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>all individuals of the data set at a given node have the same response value (the node is pure),</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>all individuals have the same covariate values,</span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a node has less than $N_{\text{min}}$ instances, $N_{\text{min}}$ being an user-defined integer value, typically set to 1 for classification.</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>Once the tree construction is complete, each leaf predicts a model index, corresponding to the majority class of its instances.</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>For a new set of explanatory variables $\xs$, predicting its model index implies passing $\xs$ through the tree, following the path of binary rules, and the predicted value is the value associated to the leaf where it falls.</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>The RF method consists in bootstrap aggregating (bagging, @breiman:1996) randomized (classification) trees. A large number of trees is trained on bootstrap samples of the training data set and $\mtry$ covariates are randomly selected at each internal node, on which the splitting rule will be defined. $\mtry$ is usually set at $\lfloor \sqrt{d} \rfloor$, where $\lfloor \cdot \rfloor$ denotes the floor function.</span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>The predicted value for a data $\xs$ is the majority vote across all tree predictions.</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>RF methods have some theoretical guarantees for sparse problems <span class="co">[</span><span class="ot">@biau:2012;@scornet:etal:2015</span><span class="co">]</span>.</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>Moreover, it is well-known that their performances are quite good even when no tuning is made.</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a><span class="fu"># Local splitting rules  {#sec-localSplittingRules}</span></span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>We now turn to discuss local tree methods. A first option to localize the tree construction is to change the information gain to the benefit of a local one. </span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>The idea is to use the test instance $\xs$ to drive the splits and thus the tree construction.</span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>Indeed, because the best split is selected on average, an eager tree may lead to many irrelevant splits to predict $\xs$, potentially discarding data</span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>relevant for the considered example at early stages of the tree. This behavior results from data fragmentation <span class="co">[</span><span class="ot">@fulton:etal:1996</span><span class="co">]</span>, i.e. from the recursive partitioning of the explanatory variables space to achieve good global performances. In the following we mention this phenomenon as the fragmentation problem.</span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a>A very simple 2-class classification problem presented in @fig-4Unif illustrates this issue. The distribution of the training data set will induce, when possible, an initial cut for the tree construction in $X_1\approx0.5$, however,</span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>the unlabeled instance (represented by a black star) is in a region where a lot of relevant instances will be discarded after this first data split. A more pertinent first cut should occur in $X_2\approx0.25$. This problem, called fragmentation problem, also leads to less significant splitting rules at deeper levels of the tree construction since based on fewer instances.</span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>It is thus interesting to consider a local approach taking $\xs$ into account.</span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.height: 4</span></span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.width: 4</span></span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4Unif</span></span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "An illustrative classification problem with 2 classes (purple and sky blye), containing two covariates describing four distinguishable regions (delimited by orange dashed lines) and an unlabeled data to classify (black star). This case will give rise to a fragmentation problem."</span></span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>safe_colorblind_palette <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"#88CCEE"</span>, <span class="st">"#CC6677"</span>, <span class="st">"#DDCC77"</span>, <span class="st">"#117733"</span>, <span class="st">"#332288"</span>, <span class="st">"#AA4499"</span>, </span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>                             <span class="st">"#44AA99"</span>, <span class="st">"#999933"</span>, <span class="st">"#882255"</span>, <span class="st">"#661100"</span>, <span class="st">"#6699CC"</span>, <span class="st">"#888888"</span>)</span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2</span>)</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>n1 <span class="ot">&lt;-</span> <span class="dv">1000</span>; n2 <span class="ot">&lt;-</span> <span class="dv">1000</span>; n3 <span class="ot">&lt;-</span> <span class="dv">300</span>; n4 <span class="ot">&lt;-</span> <span class="dv">300</span> </span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>prob_classe1_z1 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>prob_classe2_z1 <span class="ot">&lt;-</span> <span class="fl">0.75</span></span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>prob_classe1_z2 <span class="ot">&lt;-</span> <span class="fl">0.75</span></span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>prob_classe2_z2 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>prob_classe1_z3 <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>prob_classe2_z3 <span class="ot">&lt;-</span> <span class="fl">0.80</span></span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>prob_classe1_z4 <span class="ot">&lt;-</span> <span class="fl">0.80</span></span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>prob_classe2_z4 <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a><span class="co"># Zone 1, limit X1 : 0 - 0.5, limit X2 : 0.5 - 1</span></span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>b_inf_X1_z1 <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>b_sup_X1_z1 <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>b_inf_X2_z1 <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a>b_sup_X2_z1 <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>Y.train.z1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, n1<span class="sc">*</span>prob_classe1_z1), <span class="fu">rep</span>(<span class="dv">1</span>,n1<span class="sc">*</span>prob_classe2_z1))</span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>X.train.z1 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">runif</span>(n1, b_inf_X1_z1, b_sup_X1_z1) ,  <span class="fu">runif</span>(n1, b_inf_X2_z1, b_sup_X2_z1) )</span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(X.train.z1) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"X1"</span>, <span class="st">"X2"</span>)</span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a><span class="co"># Zone 2, limit X1 : 0.5 - 1, limit X2 : 0.5 - 1</span></span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>b_inf_X1_z2 <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>b_sup_X1_z2 <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>b_inf_X2_z2 <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>b_sup_X2_z2 <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>Y.train.z2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, n2<span class="sc">*</span>prob_classe1_z2), <span class="fu">rep</span>(<span class="dv">1</span>,n2<span class="sc">*</span>prob_classe2_z2))</span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>X.train.z2 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">runif</span>(n2, b_inf_X1_z2, b_sup_X1_z2) ,  <span class="fu">runif</span>(n2, b_inf_X2_z2, b_sup_X2_z2) )</span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(X.train.z2) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"X1"</span>, <span class="st">"X2"</span>)</span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a><span class="co"># Zone 3, limit X1 : 0 - 1, limit X2 : 0.25 - 0.5</span></span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a>b_inf_X1_z3 <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>b_sup_X1_z3 <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>b_inf_X2_z3 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a>b_sup_X2_z3 <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a>Y.train.z3 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, n3<span class="sc">*</span>prob_classe1_z3), <span class="fu">rep</span>(<span class="dv">1</span>, n3<span class="sc">*</span>prob_classe2_z3))</span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a>X.train.z3 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">runif</span>(n3, b_inf_X1_z3, b_sup_X1_z3) ,  <span class="fu">runif</span>(n3, b_inf_X2_z3, b_sup_X2_z3) )</span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(X.train.z3) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"X1"</span>, <span class="st">"X2"</span>)</span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a><span class="co"># Zone 4, limit X1 : 0 - 1, limit X2 : 0 - 0.25</span></span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a>b_inf_X1_z4 <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a>b_sup_X1_z4 <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a>b_inf_X2_z4 <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a>b_sup_X2_z4 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a>Y.train.z4 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, n4<span class="sc">*</span>prob_classe1_z4), <span class="fu">rep</span>(<span class="dv">1</span>, n4<span class="sc">*</span>prob_classe2_z4))</span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a>X.train.z4 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">runif</span>(n4, b_inf_X1_z4, b_sup_X1_z4) ,  <span class="fu">runif</span>(n4, b_inf_X2_z4, b_sup_X2_z4) )</span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(X.train.z4) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"X1"</span>, <span class="st">"X2"</span>)</span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a><span class="co"># Concatenate</span></span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a>Y.train <span class="ot">&lt;-</span> <span class="fu">c</span>(Y.train.z1, Y.train.z2, Y.train.z3, Y.train.z4)</span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a>X.train <span class="ot">&lt;-</span> <span class="fu">rbind</span>(X.train.z1, X.train.z2, X.train.z3, X.train.z4)</span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a><span class="do">#######</span></span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph generation</span></span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="fl">5.1</span>,<span class="fl">4.1</span>,<span class="fl">2.1</span>,<span class="fl">2.1</span>))</span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(X.train, <span class="at">col=</span>safe_colorblind_palette[Y.train<span class="sc">+</span><span class="dv">1</span>], <span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">pch=</span><span class="dv">16</span>, <span class="at">xlab=</span><span class="st">"X1"</span>, <span class="at">ylab=</span><span class="st">"X2"</span>)</span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a><span class="fu">segments</span>(<span class="at">x0=</span><span class="fl">0.5</span>, <span class="at">y0=</span><span class="fl">0.5</span>, <span class="at">x1=</span><span class="fl">0.5</span>, <span class="at">y1=</span><span class="dv">2</span>, <span class="at">col=</span><span class="st">"orange"</span>, <span class="at">lw=</span><span class="dv">2</span>, <span class="at">lty=</span><span class="dv">2</span>)</span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fl">0.5</span>, <span class="at">lty=</span><span class="dv">2</span>, <span class="at">col=</span><span class="st">"orange"</span>, <span class="at">lw=</span><span class="dv">2</span>)</span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fl">0.25</span>, <span class="at">lty=</span><span class="dv">2</span>, <span class="at">col=</span><span class="st">"orange"</span>, <span class="at">lw=</span><span class="dv">2</span>)</span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(<span class="fl">0.47</span>, <span class="fl">0.13</span>, <span class="at">pch=</span><span class="st">"*"</span>, <span class="at">cex=</span><span class="dv">3</span>)</span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a>It is interesting to note that building a local tree by modifying its internal construction results </span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a>in building a single trajectory only, since the splitting rules are only applied on branches containing $\xs$. A local tree is therefore a tool to recursively remove non-relevant data points from the classifier rule.</span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a> Thus, a local random forest might be much faster for its construction compared to the eager version, especially if only one instance is of interest.</span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a>In this section we present the approach of @friedman:etal:1997 to build local decision trees,</span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a>called lazy decision trees, and expand it for RF. We also present our attempts at using unidimensional </span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a>or multidimensional kernels to give more weight to training samples closer to $\xs$.</span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a><span class="fu">## Lazy decision trees {#sec-lazyDT}</span></span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a>The lazy decision tree algorithm (LazyDT) is introduced in @friedman:etal:1997.</span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a>Its objective is to take into account $\xs$ during the tree construction.</span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a>To do so, the information gain -- depending on $j$ and $s$ -- to maximize at</span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a>each node is modified compared to criterion @eq-critRF.</span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a>Only the difference of impurity between the mother node $t$ and the daughter node where $\xs$ ends, denoted $t^*$, is considered.</span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a>The resulting local information gain is defined by</span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a>    G_w(j,s) = I_w(t) - I_w(t^*),</span>
<span id="cb3-276"><a href="#cb3-276" aria-hidden="true" tabindex="-1"></a>$${#eq-critLazyDT}</span>
<span id="cb3-277"><a href="#cb3-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-278"><a href="#cb3-278" aria-hidden="true" tabindex="-1"></a>where $I_w$ is the information gain computed with data at the node, weighted</span>
<span id="cb3-279"><a href="#cb3-279" aria-hidden="true" tabindex="-1"></a>by a weight vector $w=(w^{(1)}, \ldots, w^{(N)})$ (described below). Note the</span>
<span id="cb3-280"><a href="#cb3-280" aria-hidden="true" tabindex="-1"></a>absence of the proportion of individuals $<span class="sc">\#</span>t_L/<span class="sc">\#</span>t$ or $<span class="sc">\#</span>t_R/<span class="sc">\#</span>t$ compared</span>
<span id="cb3-281"><a href="#cb3-281" aria-hidden="true" tabindex="-1"></a>to gain @eq-critRF.</span>
<span id="cb3-282"><a href="#cb3-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-283"><a href="#cb3-283" aria-hidden="true" tabindex="-1"></a>To ensure that this gain is always non-negative, to each instance $(y\idxi, x\idxi)$ is assigned a weight $w\idxi=\frac{1}{n_k K}$ when $y\idxi = k$ and where $n_k$ is the number of data labeled $k$ at the mother node. Indeed, this weight ensures that all the weighted class frequencies are equal at the mother node, hence the weighted mother node impurity $I_w(t)$ is maximal and the resulting gain always non-negative.</span>
<span id="cb3-284"><a href="#cb3-284" aria-hidden="true" tabindex="-1"></a>The value of $I_w(t)$ is equal to $\frac{K-1}{K}$ for the Gini index, and to</span>
<span id="cb3-285"><a href="#cb3-285" aria-hidden="true" tabindex="-1"></a>$\log(K)$ for the entropy. Due to this constant value, the maximization of</span>
<span id="cb3-286"><a href="#cb3-286" aria-hidden="true" tabindex="-1"></a>@eq-critLazyDT is equivalent to the minimization of $I_w(t^*)$. Note that the weights used at $t^*$ and $t$ are the same (limited to the sub-sample induced by the potential cut depending on $j$ and $s$ for $t^*$), but are recomputed after each accepted tree partition.</span>
<span id="cb3-287"><a href="#cb3-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-288"><a href="#cb3-288" aria-hidden="true" tabindex="-1"></a>Moreover, those weights also avoid the problem that the impurity measures only use the classes proportions, without distinction of their associated class labels.</span>
<span id="cb3-289"><a href="#cb3-289" aria-hidden="true" tabindex="-1"></a>Indeed, let us take the example of a two-class classification problem (1 and 2), where the mother node contains $80\%$ of data labeled 1 and $20\%$ labeled 2. A splitting rule computed on unweighted data might induce, at the daughter node where $\xs$ falls, $20\%$ and $80\%$ as proportions of 1 and 2, respectively.</span>
<span id="cb3-290"><a href="#cb3-290" aria-hidden="true" tabindex="-1"></a>In this way, the non-weighted gain @eq-critLazyDT would be zero, even though the discriminatory power of this cut is clearly non-null.</span>
<span id="cb3-291"><a href="#cb3-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-292"><a href="#cb3-292" aria-hidden="true" tabindex="-1"></a>LazyDT provides three other major features: the use of discretised explanatory variables, the use of options and a condition on allowed split events.</span>
<span id="cb3-293"><a href="#cb3-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-294"><a href="#cb3-294" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>This algorithm only handles discretised explanatory variables. A preliminary discretisation is thus necessary, using for example the minimum description length principle <span class="co">[</span><span class="ot">@fayyad:irani:1995</span><span class="co">]</span>. This was initially introduced to enhance the algorithm speed. </span>
<span id="cb3-295"><a href="#cb3-295" aria-hidden="true" tabindex="-1"></a>    According to our experiments this might also be useful when continuous</span>
<span id="cb3-296"><a href="#cb3-296" aria-hidden="true" tabindex="-1"></a>    noise variables are considered as features as splitting along them may</span>
<span id="cb3-297"><a href="#cb3-297" aria-hidden="true" tabindex="-1"></a>    result in early strop of the algorithm. For instance in @fig-early below, $\xs_1$ is  localized at a border of x1 values, together with two datapoints with same label. The next splitting rule will isolate them with $\xs_1$ because the resulting node will be pure and hence provide the maximum gain. $\xs$ would thus be classified as sky-blue,  even though a cut along x2 would have resulted in a purple prediction using many more datapoints. The discretisation will be an asset in such situations since pure noise variables are more likely to be discretised into a unique or few categories containing large amount of data.</span>
<span id="cb3-298"><a href="#cb3-298" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The use of *options* is introduced. Indeed, because features can induce very similar information gains, @friedman:etal:1997 advise to develop all the paths -- induced by splitting rules -- achieving at least $90\%$ of the maximal possible gain. The prediction associated to a tree for $\xs$ becomes the prediction of the leaf with the maximal number of individuals in its majority class. We tried values different from $90\%$ and it did not provide better results.</span>
<span id="cb3-299"><a href="#cb3-299" aria-hidden="true" tabindex="-1"></a>    Moreover, we studied an alternative to this method of prediction: because each option provides a prediction for $\xs$, we considered taking as final prediction the majority vote of these option predictions, but again</span>
<span id="cb3-300"><a href="#cb3-300" aria-hidden="true" tabindex="-1"></a>    results were not more conclusive.</span>
<span id="cb3-301"><a href="#cb3-301" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Finally, LazyDT only considers split values that are not equal to the values of $\xs$ as potential cuts.</span>
<span id="cb3-302"><a href="#cb3-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-303"><a href="#cb3-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-306"><a href="#cb3-306" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-307"><a href="#cb3-307" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.height: 4</span></span>
<span id="cb3-308"><a href="#cb3-308" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.width: 4</span></span>
<span id="cb3-309"><a href="#cb3-309" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-early</span></span>
<span id="cb3-310"><a href="#cb3-310" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-311"><a href="#cb3-311" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-312"><a href="#cb3-312" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "An illustrative classification problem with 2 classes (purple and sky blye), containing an informative covariate (x2) and a non-informative covariate (x1) and an unlabeled data to classify (black star). Splitting along x1 will result in a pure leaf with sky-blue label."</span></span>
<span id="cb3-313"><a href="#cb3-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-314"><a href="#cb3-314" aria-hidden="true" tabindex="-1"></a>safe_colorblind_palette <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"#88CCEE"</span>, <span class="st">"#CC6677"</span>, <span class="st">"#DDCC77"</span>, <span class="st">"#117733"</span>, <span class="st">"#332288"</span>, <span class="st">"#AA4499"</span>, </span>
<span id="cb3-315"><a href="#cb3-315" aria-hidden="true" tabindex="-1"></a>                             <span class="st">"#44AA99"</span>, <span class="st">"#999933"</span>, <span class="st">"#882255"</span>, <span class="st">"#661100"</span>, <span class="st">"#6699CC"</span>, <span class="st">"#888888"</span>)</span>
<span id="cb3-316"><a href="#cb3-316" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2</span>)</span>
<span id="cb3-317"><a href="#cb3-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-318"><a href="#cb3-318" aria-hidden="true" tabindex="-1"></a>n1 <span class="ot">&lt;-</span> <span class="dv">100</span>; n2 <span class="ot">&lt;-</span> <span class="dv">100</span>; </span>
<span id="cb3-319"><a href="#cb3-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-320"><a href="#cb3-320" aria-hidden="true" tabindex="-1"></a>x1<span class="ot">=</span><span class="fu">runif</span>(n1<span class="dv">-2</span>,<span class="dv">0</span>,<span class="fl">0.95</span>)</span>
<span id="cb3-321"><a href="#cb3-321" aria-hidden="true" tabindex="-1"></a>x2<span class="ot">=</span><span class="fu">runif</span>(n2,<span class="dv">0</span>,<span class="fl">0.95</span>)</span>
<span id="cb3-322"><a href="#cb3-322" aria-hidden="true" tabindex="-1"></a>y1<span class="ot">=</span><span class="fu">runif</span>(n1<span class="dv">-2</span>,<span class="fl">0.5</span>,<span class="dv">1</span>)</span>
<span id="cb3-323"><a href="#cb3-323" aria-hidden="true" tabindex="-1"></a>y2<span class="ot">=</span><span class="fu">runif</span>(n2,<span class="dv">0</span>,<span class="fl">0.5</span>)</span>
<span id="cb3-324"><a href="#cb3-324" aria-hidden="true" tabindex="-1"></a>x1p<span class="ot">=</span><span class="fu">c</span>(<span class="fl">0.97</span>,<span class="fl">0.99</span>)</span>
<span id="cb3-325"><a href="#cb3-325" aria-hidden="true" tabindex="-1"></a>y1p<span class="ot">=</span><span class="fu">c</span>(<span class="fl">0.8</span>,<span class="fl">0.6</span>)</span>
<span id="cb3-326"><a href="#cb3-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-327"><a href="#cb3-327" aria-hidden="true" tabindex="-1"></a>Y.train <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, n1), <span class="fu">rep</span>(<span class="dv">1</span>,n2))</span>
<span id="cb3-328"><a href="#cb3-328" aria-hidden="true" tabindex="-1"></a>X.train <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">cbind</span>(x1,y1),<span class="fu">cbind</span>(x1p,y1p),<span class="fu">cbind</span>(x2,y2))</span>
<span id="cb3-329"><a href="#cb3-329" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(X.train) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"X1"</span>, <span class="st">"X2"</span>)</span>
<span id="cb3-330"><a href="#cb3-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-331"><a href="#cb3-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-332"><a href="#cb3-332" aria-hidden="true" tabindex="-1"></a><span class="do">#######</span></span>
<span id="cb3-333"><a href="#cb3-333" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph generation</span></span>
<span id="cb3-334"><a href="#cb3-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-335"><a href="#cb3-335" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="fl">5.1</span>,<span class="fl">4.1</span>,<span class="fl">2.1</span>,<span class="fl">2.1</span>))</span>
<span id="cb3-336"><a href="#cb3-336" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(X.train, <span class="at">col=</span>safe_colorblind_palette[Y.train<span class="sc">+</span><span class="dv">1</span>], <span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">pch=</span><span class="dv">16</span>, <span class="at">xlab=</span><span class="st">"X1"</span>, <span class="at">ylab=</span><span class="st">"X2"</span>)</span>
<span id="cb3-337"><a href="#cb3-337" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fl">0.955</span>, <span class="at">lty=</span><span class="dv">2</span>, <span class="at">col=</span><span class="st">"orange"</span>, <span class="at">lw=</span><span class="dv">2</span>)</span>
<span id="cb3-338"><a href="#cb3-338" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(<span class="fl">0.98</span>, <span class="fl">0.13</span>, <span class="at">pch=</span><span class="st">"*"</span>, <span class="at">cex=</span><span class="dv">3</span>)</span>
<span id="cb3-339"><a href="#cb3-339" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-340"><a href="#cb3-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-341"><a href="#cb3-341" aria-hidden="true" tabindex="-1"></a>The LazyDT algorithm has undergone some developments. First, a bagged version to deduce class probabilities is presented in @margineantu:dietterich:2003. A boosted version is then introduced in @fern:etal:2003. @friedman:etal:1997 mention as main drawback for this method its inability to allow pruning. @fern:etal:2003 propose a heuristic to overcome this drawback, but their algorithm is not guaranteed to improve the classifier accuracy.</span>
<span id="cb3-342"><a href="#cb3-342" aria-hidden="true" tabindex="-1"></a>Considering trees-ensemble overcomes this weakness.</span>
<span id="cb3-343"><a href="#cb3-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-344"><a href="#cb3-344" aria-hidden="true" tabindex="-1"></a><span class="fu">## Unidimensional (per covariate) kernel approach {#sec-localKernel}</span></span>
<span id="cb3-345"><a href="#cb3-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-346"><a href="#cb3-346" aria-hidden="true" tabindex="-1"></a>Most local methods are based on weights depending on the proximity to $\xs$. This is the case of locally weighted regression</span>
<span id="cb3-347"><a href="#cb3-347" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@cleveland:1979;@cleveland:devlin:1988; @fan:1993; @hastie:loader:1993</span><span class="co">]</span>. There are different ways to use weights </span>
<span id="cb3-348"><a href="#cb3-348" aria-hidden="true" tabindex="-1"></a>in the context of tree methods. One can think of taking into account these weights to define the training sets on which </span>
<span id="cb3-349"><a href="#cb3-349" aria-hidden="true" tabindex="-1"></a>trees are built. Such type of strategy is described in @sec-localWeightingOfIndividuls.</span>
<span id="cb3-350"><a href="#cb3-350" aria-hidden="true" tabindex="-1"></a>In this section, we examine the possibility of using weights during tree construction, inside the tree splitting criterion.</span>
<span id="cb3-351"><a href="#cb3-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-352"><a href="#cb3-352" aria-hidden="true" tabindex="-1"></a>In the wake of locally weighted regression, we set a weight to each training individual and per covariate $j$ depending on its proximity to $\xsj$ in the covariate $j$ space. We consider a Gaussian kernel centered in $\xsj$, </span>
<span id="cb3-353"><a href="#cb3-353" aria-hidden="true" tabindex="-1"></a>providing weights </span>
<span id="cb3-354"><a href="#cb3-354" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-355"><a href="#cb3-355" aria-hidden="true" tabindex="-1"></a>K_{h_j}(x_j^{(i)} - x_j^*), \;\; \text{for} \;\; i\in<span class="sc">\{</span>1,\ldots,N<span class="sc">\}</span>.</span>
<span id="cb3-356"><a href="#cb3-356" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-357"><a href="#cb3-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-358"><a href="#cb3-358" aria-hidden="true" tabindex="-1"></a>We focus on a Gaussian kernel due to its smoothness and to avoid giving</span>
<span id="cb3-359"><a href="#cb3-359" aria-hidden="true" tabindex="-1"></a>exactly zero weights to some individuals, so that $K_{h_j}(x_j^{(i)} - x_j^*)=1/(\sqrt{2\pi} h_j) \exp\left(-\frac{(x_j^{(i)} - \xsj)^2}{2h_j^2}\right)$.</span>
<span id="cb3-360"><a href="#cb3-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-361"><a href="#cb3-361" aria-hidden="true" tabindex="-1"></a>The choice of the bandwidth $h_j$ is tricky. We consider as bandwidth value $h_j$ the quantile of </span>
<span id="cb3-362"><a href="#cb3-362" aria-hidden="true" tabindex="-1"></a>order $\alpha$ of the distribution of distances to $\xs$: $\mathbb{Q}_\alpha \left\{ \mid x_j^{(i)} - \xsj \mid_{i=1, \ldots, N} \right\}$ (ie $h_j=d^j_{(\alpha N)}$ where $d^j_{(1)},\dots ,d^j_{(N)}$ are the ordered distances $\mid x_j^{(i)} - \xsj \mid$ of the training data points to $\xs$ in the covariate $j$ space).</span>
<span id="cb3-363"><a href="#cb3-363" aria-hidden="true" tabindex="-1"></a>The parameter $\alpha$ determines the shape of the kernel. For low $\alpha$ values, a higher weight is given to data close to $\xs$, and vice-versa. In our numerical experiments, we clearly observed that low</span>
<span id="cb3-364"><a href="#cb3-364" aria-hidden="true" tabindex="-1"></a>values of $\alpha$ again result in cuts too close to $\xsj$. We set $\alpha=1$, i.e. $h_j$ is the maximum of the absolute values considered.</span>
<span id="cb3-365"><a href="#cb3-365" aria-hidden="true" tabindex="-1"></a>Moreover, the bandwidth can eventually be recalculated at each internal node or kept constant during the tree construction.</span>
<span id="cb3-366"><a href="#cb3-366" aria-hidden="true" tabindex="-1"></a>We observed very few differences when using a fixed or a varying</span>
<span id="cb3-367"><a href="#cb3-367" aria-hidden="true" tabindex="-1"></a>bandwidth and $h_j$ is set as constant in the following.</span>
<span id="cb3-368"><a href="#cb3-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-369"><a href="#cb3-369" aria-hidden="true" tabindex="-1"></a>For a given class label $k$, at the mother node $t$, this approach transforms the usual class frequencies </span>
<span id="cb3-370"><a href="#cb3-370" aria-hidden="true" tabindex="-1"></a>(giving uniform weights among data) into some weighted class frequencies in the following way:</span>
<span id="cb3-371"><a href="#cb3-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-372"><a href="#cb3-372" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-373"><a href="#cb3-373" aria-hidden="true" tabindex="-1"></a>    p_k  = \frac{\sum_{i:x^{(i)}\in t} \mathbf{1}<span class="sc">\{</span> y^{(i)}=k <span class="sc">\}</span>}{<span class="sc">\#</span>t} \quad \Rightarrow \quad  \;\;\; \widetilde{p}_{k,j} = \frac{\sum_{i:x\idxi\in t} \mathbf{1}\{ y\idxi=k \}  K_{h_j}(x_j^{(i)} - x_j^*)}{\sum_{\ell:x^{(\ell)}\in t} K_{h_j}(x_j^{(\ell)} - x_j^*)},</span>
<span id="cb3-374"><a href="#cb3-374" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-375"><a href="#cb3-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-376"><a href="#cb3-376" aria-hidden="true" tabindex="-1"></a>where $\mathbf{1}<span class="sc">\{</span>\cdot<span class="sc">\}</span>$ is the indicator function.</span>
<span id="cb3-377"><a href="#cb3-377" aria-hidden="true" tabindex="-1"></a>Moreover, the proportion of individuals, for example, at the left daughter node $t_L$ implied by a cut $X_j \leq s$ is transformed from</span>
<span id="cb3-378"><a href="#cb3-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-379"><a href="#cb3-379" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-380"><a href="#cb3-380" aria-hidden="true" tabindex="-1"></a>    \frac{<span class="sc">\#</span>t_L}{<span class="sc">\#</span>t} = \frac{\sum_{i:x\idxi\in t} \mathbf{1}<span class="sc">\{</span> x_j^{(i)} \leq s <span class="sc">\}</span>}{<span class="sc">\#</span>t}</span>
<span id="cb3-381"><a href="#cb3-381" aria-hidden="true" tabindex="-1"></a>\quad \text{into} \quad</span>
<span id="cb3-382"><a href="#cb3-382" aria-hidden="true" tabindex="-1"></a>      \frac{\widetilde{<span class="sc">\#</span>t_L}}{\widetilde{<span class="sc">\#</span>t}} = \frac{\sum_{i:x\idxi\in t} \mathbf{1}<span class="sc">\{</span> x_j^{(i)} \leq s <span class="sc">\}</span> </span>
<span id="cb3-383"><a href="#cb3-383" aria-hidden="true" tabindex="-1"></a>K_{h_j}(x_j^{(i)} - x_j^*)}{\sum_{\ell:x^{(\ell)}\in t}</span>
<span id="cb3-384"><a href="#cb3-384" aria-hidden="true" tabindex="-1"></a>K_{h_j}(x_j^{(\ell)} - x_j^*)}.</span>
<span id="cb3-385"><a href="#cb3-385" aria-hidden="true" tabindex="-1"></a>$${#eq-kernelProp}</span>
<span id="cb3-386"><a href="#cb3-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-387"><a href="#cb3-387" aria-hidden="true" tabindex="-1"></a>The information gain to maximize (based on the Gini index) thus becomes</span>
<span id="cb3-388"><a href="#cb3-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-389"><a href="#cb3-389" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-390"><a href="#cb3-390" aria-hidden="true" tabindex="-1"></a>   \sum_{k=1}^K  \widetilde{p}_{k,j} (1-\widetilde{p}_{k,j}) </span>
<span id="cb3-391"><a href="#cb3-391" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>\Big(\frac{\widetilde{<span class="sc">\#</span>t_L}}{\widetilde{<span class="sc">\#</span>t}}  </span>
<span id="cb3-392"><a href="#cb3-392" aria-hidden="true" tabindex="-1"></a>  \sum_{k=1}^K \widetilde{p}_{k,j}^L (1-\widetilde{p}_{k,j}^L)  </span>
<span id="cb3-393"><a href="#cb3-393" aria-hidden="true" tabindex="-1"></a>   +\frac{\widetilde{<span class="sc">\#</span>t_R}}{\widetilde{<span class="sc">\#</span>t}}</span>
<span id="cb3-394"><a href="#cb3-394" aria-hidden="true" tabindex="-1"></a>    \sum_{k=1}^K \widetilde{p}_{k,j}^R (1-\widetilde{p}_{k,j}^R) </span>
<span id="cb3-395"><a href="#cb3-395" aria-hidden="true" tabindex="-1"></a>\Big)</span>
<span id="cb3-396"><a href="#cb3-396" aria-hidden="true" tabindex="-1"></a>$${#eq-critlocalKernel}</span>
<span id="cb3-397"><a href="#cb3-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-398"><a href="#cb3-398" aria-hidden="true" tabindex="-1"></a>where $\widetilde{p}_{k,j}^L$ and $\widetilde{p}_{k,j}^R$ are the weighted proportions </span>
<span id="cb3-399"><a href="#cb3-399" aria-hidden="true" tabindex="-1"></a>of class $k$ at the left and right daughter nodes, respectively.</span>
<span id="cb3-400"><a href="#cb3-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-401"><a href="#cb3-401" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-402"><a href="#cb3-402" aria-hidden="true" tabindex="-1"></a>\let\scriptstyle\textstyle\substack{\widetilde{I_j}(t)}=\sum_{k=1}^K  \widetilde{p}_{k,j} (1-\widetilde{p}_{k,j})</span>
<span id="cb3-403"><a href="#cb3-403" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-404"><a href="#cb3-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-405"><a href="#cb3-405" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-406"><a href="#cb3-406" aria-hidden="true" tabindex="-1"></a>\let\scriptstyle\textstyle\substack{\widetilde{I_j}(t_L)}=\sum_{k=1}^K \widetilde{p}_{k,j}^L (1-\widetilde{p}_{k,j}^L)</span>
<span id="cb3-407"><a href="#cb3-407" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-408"><a href="#cb3-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-409"><a href="#cb3-409" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-410"><a href="#cb3-410" aria-hidden="true" tabindex="-1"></a>\let\scriptstyle\textstyle\substack{\widetilde{I_j}(t_R)}=\sum_{k=1}^K \widetilde{p}_{k,j}^R (1-\widetilde{p}_{k,j}^R)</span>
<span id="cb3-411"><a href="#cb3-411" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-412"><a href="#cb3-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-413"><a href="#cb3-413" aria-hidden="true" tabindex="-1"></a>The first term $\widetilde{I_j}(t)$ is important and cannot be omitted contrary </span>
<span id="cb3-414"><a href="#cb3-414" aria-hidden="true" tabindex="-1"></a>to the eager version, because it depends on the covariate index. </span>
<span id="cb3-415"><a href="#cb3-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-416"><a href="#cb3-416" aria-hidden="true" tabindex="-1"></a>We use this local Gini index during the tree construction and </span>
<span id="cb3-417"><a href="#cb3-417" aria-hidden="true" tabindex="-1"></a>do not modify the default values for the RF parameters $\mtry$ and $\Nmin$.</span>
<span id="cb3-418"><a href="#cb3-418" aria-hidden="true" tabindex="-1"></a>For each tree, the associated prediction is the usual majority vote at the leaf.</span>
<span id="cb3-419"><a href="#cb3-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-420"><a href="#cb3-420" aria-hidden="true" tabindex="-1"></a>Our local splitting rule is similar to the one used in the recent method of @armano:tamponi:2018. </span>
<span id="cb3-421"><a href="#cb3-421" aria-hidden="true" tabindex="-1"></a>In their work, an improvement to RF is introduced by using an ensemble of local trees. </span>
<span id="cb3-422"><a href="#cb3-422" aria-hidden="true" tabindex="-1"></a>Each tree is trained giving more weight to training data around a centroid,</span>
<span id="cb3-423"><a href="#cb3-423" aria-hidden="true" tabindex="-1"></a>which is sampled among the training instances, </span>
<span id="cb3-424"><a href="#cb3-424" aria-hidden="true" tabindex="-1"></a>and different centroids are considered to map the whole predictor space. </span>
<span id="cb3-425"><a href="#cb3-425" aria-hidden="true" tabindex="-1"></a>Although using a local Gini index, this approach is more of an eager one than a local one.</span>
<span id="cb3-426"><a href="#cb3-426" aria-hidden="true" tabindex="-1"></a>Indeed, no test instance is involved during the forest construction.</span>
<span id="cb3-427"><a href="#cb3-427" aria-hidden="true" tabindex="-1"></a>Moreover, a multidimensional kernel per tree is used.</span>
<span id="cb3-428"><a href="#cb3-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-429"><a href="#cb3-429" aria-hidden="true" tabindex="-1"></a><span class="fu">## Multidimensional kernel approach {#sec-localKernelMultiDim}</span></span>
<span id="cb3-430"><a href="#cb3-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-431"><a href="#cb3-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-432"><a href="#cb3-432" aria-hidden="true" tabindex="-1"></a>In the spirit of @armano:tamponi:2018, it is natural to extend the approach introduced </span>
<span id="cb3-433"><a href="#cb3-433" aria-hidden="true" tabindex="-1"></a>in @sec-localKernel with a multidimensional kernel centered in $\xs$.</span>
<span id="cb3-434"><a href="#cb3-434" aria-hidden="true" tabindex="-1"></a>We assign to each data $(y\idxi,x\idxi)$ a weight</span>
<span id="cb3-435"><a href="#cb3-435" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-436"><a href="#cb3-436" aria-hidden="true" tabindex="-1"></a>K_V(x^{(i)}-x^*) = 1/(2\pi)^{d/2}\exp{ \left( -\frac{1}{2}(x\idxi - \xs)^\top V^{-2} (x\idxi - \xs) \right)},</span>
<span id="cb3-437"><a href="#cb3-437" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-438"><a href="#cb3-438" aria-hidden="true" tabindex="-1"></a>where $V$ is a scaling matrix of the Gaussian kernel.</span>
<span id="cb3-439"><a href="#cb3-439" aria-hidden="true" tabindex="-1"></a>Similarly to @sec-localKernel we consider for $V$ the diagonal matrix made of the $\alpha$ quantiles, i.e.</span>
<span id="cb3-440"><a href="#cb3-440" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-441"><a href="#cb3-441" aria-hidden="true" tabindex="-1"></a>V= \diag\left(\mathbb{Q}_\alpha \left\{ \mid x_1\idxi - x_1^* \mid_{i=1, \ldots, N} \right\}, \ldots, \mathbb{Q}_\alpha \left\{ \mid x_d\idxi - x_d^*\mid_{i=1, \ldots, N} \right<span class="sc">\}</span> \right).</span>
<span id="cb3-442"><a href="#cb3-442" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-443"><a href="#cb3-443" aria-hidden="true" tabindex="-1"></a>As for the unidimensional kernel approach, using extensive numerical experiments, we observed that low values of $\alpha$ result in cuts too close to $\xsj$ and we set $\alpha=1$. Also, the weights are fixed</span>
<span id="cb3-444"><a href="#cb3-444" aria-hidden="true" tabindex="-1"></a>during the tree construction. </span>
<span id="cb3-445"><a href="#cb3-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-446"><a href="#cb3-446" aria-hidden="true" tabindex="-1"></a>The weighted frequency for a given class label $k$ becomes</span>
<span id="cb3-447"><a href="#cb3-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-448"><a href="#cb3-448" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-449"><a href="#cb3-449" aria-hidden="true" tabindex="-1"></a>    \widetilde{p}_k = \frac{\sum_{i=1}^N  \mathbf{1}<span class="sc">\{</span> y\idxi=k <span class="sc">\}</span> </span>
<span id="cb3-450"><a href="#cb3-450" aria-hidden="true" tabindex="-1"></a>K_V(x^{(i)}-x^*)}{\sum_{\ell=1}^N K_V(x^{(\ell)}-x^*)}.</span>
<span id="cb3-451"><a href="#cb3-451" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-452"><a href="#cb3-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-453"><a href="#cb3-453" aria-hidden="true" tabindex="-1"></a>The weighted proportions of individual at the daughter nodes are transformed</span>
<span id="cb3-454"><a href="#cb3-454" aria-hidden="true" tabindex="-1"></a>in a similar manner to @eq-kernelProp, resulting in a gain criterion analogous</span>
<span id="cb3-455"><a href="#cb3-455" aria-hidden="true" tabindex="-1"></a>to @eq-critlocalKernel.</span>
<span id="cb3-456"><a href="#cb3-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-457"><a href="#cb3-457" aria-hidden="true" tabindex="-1"></a>The major benefit of such weights is that they do not depend on the covariate index, thus the usual tree prediction, </span>
<span id="cb3-458"><a href="#cb3-458" aria-hidden="true" tabindex="-1"></a>i.e. the majority class at the leaf where $\xs$ falls, can be replaced by a more coherent strategy with the tree </span>
<span id="cb3-459"><a href="#cb3-459" aria-hidden="true" tabindex="-1"></a>construction, using as prediction the class with the maximal weighted class proportion at the leaf.</span>
<span id="cb3-460"><a href="#cb3-460" aria-hidden="true" tabindex="-1"></a>Thus, the prediction for $\xs$ provided by the $b$-th tree is</span>
<span id="cb3-461"><a href="#cb3-461" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-462"><a href="#cb3-462" aria-hidden="true" tabindex="-1"></a>    \hat{y}_b^* = \argmax_{1\leq k \leq K} \widetilde{p}_k.</span>
<span id="cb3-463"><a href="#cb3-463" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-464"><a href="#cb3-464" aria-hidden="true" tabindex="-1"></a>The forest prediction for $\xs$ is the usual majority vote of the tree predictions.</span>
<span id="cb3-465"><a href="#cb3-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-466"><a href="#cb3-466" aria-hidden="true" tabindex="-1"></a><span class="fu"># Local weighting of individuals {#sec-localWeightingOfIndividuls}</span></span>
<span id="cb3-467"><a href="#cb3-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-468"><a href="#cb3-468" aria-hidden="true" tabindex="-1"></a>To avoid the fragmentation problem, instead of modifying the way the predictor space is partitioned, one can consider directly targeting the region of interest, i.e. samples similar to $\xs$. In this part, we focus on strategies acting on the individuals sampling schemes involved at the first step of a tree construction, replacing the usual bootstrap sampling with a local one.</span>
<span id="cb3-469"><a href="#cb3-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-470"><a href="#cb3-470" aria-hidden="true" tabindex="-1"></a><span class="fu">## Weighted bootstrap {#sec-weightingIndividuals}</span></span>
<span id="cb3-471"><a href="#cb3-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-472"><a href="#cb3-472" aria-hidden="true" tabindex="-1"></a>@xu:etal:2016 propose to perform weighted bootstrap sampling, where a measure of proximity between $\xs$ and the training data is used to compute the weights. This algorithm is entitled Case-Specific Random Forest (CSRF, Algorithm 1).</span>
<span id="cb3-473"><a href="#cb3-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-474"><a href="#cb3-474" aria-hidden="true" tabindex="-1"></a>An individual closer to $\xs$ will have higher weight and will more likely be picked in the bootstrap sampling.</span>
<span id="cb3-475"><a href="#cb3-475" aria-hidden="true" tabindex="-1"></a>However, such weights depend heavily on the choice of the proximity measure, especially in a high dimensional setting and with many irrelevant explanatory variables. This is why in this framework the proximity measure will be automatically computed thanks to a bagged tree-ensemble (i.e. with $\mtry=d$).</span>
<span id="cb3-476"><a href="#cb3-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-477"><a href="#cb3-477" aria-hidden="true" tabindex="-1"></a>Indeed, for a given tree, $\xs$ ends in a leaf with some training data. For each $x\idxi$, counting the number of trees where $\xs$ and $x\idxi$ end in the same leaf allows to compute the contribution of $x\idxi$ to predict $\xs$, denoted $\omega\idxi$ in Algorithm 1.</span>
<span id="cb3-478"><a href="#cb3-478" aria-hidden="true" tabindex="-1"></a>The deduced weights are then used to perform weighted bootstrap sampling during the training of a new RF. This process can be seen as a nearest neighbors strategy: per tree, a leaf provides a certain amount of neighbors to $\xs$, those are then accumulated over all the trees to deduce instance weights.</span>
<span id="cb3-479"><a href="#cb3-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-480"><a href="#cb3-480" aria-hidden="true" tabindex="-1"></a>This algorithm highly depends on the depth of the first RF trees, hence a pivotal parameter for this strategy is $N_{\text{min}}$, the minimal number of observations at an internal node.</span>
<span id="cb3-481"><a href="#cb3-481" aria-hidden="true" tabindex="-1"></a>The higher $N_{\text{min}}$, the shallower the trees will be. Hence, low values of $N_{\text{min}}$ result in putting more weight on the closest individuals to $\xs$, and vice-versa. We tried various values of $\Nmin$ in our experiments, and find that optimal performance require $Nmin$ not to be too small.</span>
<span id="cb3-482"><a href="#cb3-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-483"><a href="#cb3-483" aria-hidden="true" tabindex="-1"></a>******</span>
<span id="cb3-484"><a href="#cb3-484" aria-hidden="true" tabindex="-1"></a>**Algorithm 1**:  CSRF -- local weighting of individuals</span>
<span id="cb3-485"><a href="#cb3-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-486"><a href="#cb3-486" aria-hidden="true" tabindex="-1"></a>******</span>
<span id="cb3-487"><a href="#cb3-487" aria-hidden="true" tabindex="-1"></a>  Step 1.  Grow $B_1$ bootstrapped trees with $\mtry=d$ and a given $\Nmin$ value </span>
<span id="cb3-488"><a href="#cb3-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-489"><a href="#cb3-489" aria-hidden="true" tabindex="-1"></a>  Step 2.  For each training data $(y\idxi, x\idxi)$, count $c\idxi$ the number of times $x\idxi$ and $\xs$ end in the same leaf</span>
<span id="cb3-490"><a href="#cb3-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-491"><a href="#cb3-491" aria-hidden="true" tabindex="-1"></a>  Step 3.  Compute the resampling probability of the training individual $i$ relative to $\xs$ as $\omega\idxi=\frac{c\idxi}{\sum_{\ell=1}^N c^{(\ell)}}$, for $i \in \left<span class="sc">\{</span> 1, \ldots, N \right<span class="sc">\}</span>$</span>
<span id="cb3-492"><a href="#cb3-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-493"><a href="#cb3-493" aria-hidden="true" tabindex="-1"></a>  Step 4. Train a usual RF of size $B_2$ with bootstrap resampling probabilities </span>
<span id="cb3-494"><a href="#cb3-494" aria-hidden="true" tabindex="-1"></a>   $\omega^{(1)}, \ldots, \omega^{(N)}$ and deduce the prediction for $\xs$</span>
<span id="cb3-495"><a href="#cb3-495" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb3-496"><a href="#cb3-496" aria-hidden="true" tabindex="-1"></a>******</span>
<span id="cb3-497"><a href="#cb3-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-498"><a href="#cb3-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-499"><a href="#cb3-499" aria-hidden="true" tabindex="-1"></a><span class="fu">## Nearest neighbours: 0/1 weights {#sec-nearest-neighbours}</span></span>
<span id="cb3-500"><a href="#cb3-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-501"><a href="#cb3-501" aria-hidden="true" tabindex="-1"></a>A more intuitive idea is based on the deduction of $\kappa$ nearest neighbors (NN) to $\xs$, which are then used to train an RF.</span>
<span id="cb3-502"><a href="#cb3-502" aria-hidden="true" tabindex="-1"></a>@fulton:etal:1996 propose several methods to extract data local to $\xs$ -- the best one being based on NN -- in order to build decision trees on this restricted training set.</span>
<span id="cb3-503"><a href="#cb3-503" aria-hidden="true" tabindex="-1"></a>@galvan:etal:2009 also mention the possibility of pre-selecting closest observations to $\xs$ (possibly with replicates) at first and applying any machine learning algorithm on these data set.</span>
<span id="cb3-504"><a href="#cb3-504" aria-hidden="true" tabindex="-1"></a>This kind of strategy is more recently applied in a text classification framework by @salles:etal:2018, and shows good improvements in terms of classification errors compared to RF (and other ones).</span>
<span id="cb3-505"><a href="#cb3-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-506"><a href="#cb3-506" aria-hidden="true" tabindex="-1"></a>Those approaches are closely related to CSRF (@sec-weightingIndividuals) since considering NN during a preliminary step is equivalent to giving 0/1 sampling weights (with or without replacement).</span>
<span id="cb3-507"><a href="#cb3-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-508"><a href="#cb3-508" aria-hidden="true" tabindex="-1"></a>In @sec-examples, we compare the use of a preliminary selection of nearest neighbors to $\xs$ followed by a usual RF training, this strategy is denoted in the remaining by NN-RF, for nearest neighbors - random forest. The main issue of such approaches (and local ones in general) is the difficulty to choose this neighborhood.</span>
<span id="cb3-509"><a href="#cb3-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-510"><a href="#cb3-510" aria-hidden="true" tabindex="-1"></a><span class="fu"># Local weighting of covariates {#sec-weightingCovariates}</span></span>
<span id="cb3-511"><a href="#cb3-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-512"><a href="#cb3-512" aria-hidden="true" tabindex="-1"></a>Instead of acting on the bootstrap resampling of RF, we propose to operate on</span>
<span id="cb3-513"><a href="#cb3-513" aria-hidden="true" tabindex="-1"></a>the covariates subsampling which occurs at each internal node. In the wake of</span>
<span id="cb3-514"><a href="#cb3-514" aria-hidden="true" tabindex="-1"></a>@sec-weightingIndividuals we propose to weight covariates during the RF trees construction depending on their importance to predict $\xs$. In the following we mention it as LVI-RF (for local variable importance - random forest).</span>
<span id="cb3-515"><a href="#cb3-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-516"><a href="#cb3-516" aria-hidden="true" tabindex="-1"></a>We study the influence of considering sampling probability weights on explanatory variables.</span>
<span id="cb3-517"><a href="#cb3-517" aria-hidden="true" tabindex="-1"></a>The principle is detailed in Algorithm 2 and is very similar to Algorithm 1.</span>
<span id="cb3-518"><a href="#cb3-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-519"><a href="#cb3-519" aria-hidden="true" tabindex="-1"></a>We take profit of a first RF construction with default parameters to deduce covariate importance to predict $\xs$: in a very intuitive way we pass $\xs$ through each tree of the RF, and count the number of times each covariate is involved in a splitting rule to allocate $\xs$.</span>
<span id="cb3-520"><a href="#cb3-520" aria-hidden="true" tabindex="-1"></a>We can then easily deduce some predictor weights, and we propose to introduce them into the usual RF covariate sampling, so that a covariate with high weight is more likely to be drawn in the $\mtry$-sample.</span>
<span id="cb3-521"><a href="#cb3-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-522"><a href="#cb3-522" aria-hidden="true" tabindex="-1"></a>Our thought is that using such weights might improve the prediction accuracy of the RF, especially in a sparse framework, by avoiding useless data fragmentation according to irrelevant predictors and potential loss of useful training data for the prediction of $\xs$.</span>
<span id="cb3-523"><a href="#cb3-523" aria-hidden="true" tabindex="-1"></a>Moreover, a different set of explanatory variables might be useful to predict different test instances, thus thanks to a local measure of variable importance we also try to ensure that interesting covariates are more likely to be sampled during the tree construction.</span>
<span id="cb3-524"><a href="#cb3-524" aria-hidden="true" tabindex="-1"></a>Finally, in the case of a huge number of noise covariates, even though RF can handle a large number of features, useful ones are very unlikely to be drawn during the tree construction, deteriorating the algorithm performance.</span>
<span id="cb3-525"><a href="#cb3-525" aria-hidden="true" tabindex="-1"></a>In counterpart, weighted covariate sampling might increase the prediction correlation between the RF trees and alter the performance of the global tree ensemble. </span>
<span id="cb3-526"><a href="#cb3-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-527"><a href="#cb3-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-528"><a href="#cb3-528" aria-hidden="true" tabindex="-1"></a>******</span>
<span id="cb3-529"><a href="#cb3-529" aria-hidden="true" tabindex="-1"></a>**Algorithm 2**:  Local weighting of covariates</span>
<span id="cb3-530"><a href="#cb3-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-531"><a href="#cb3-531" aria-hidden="true" tabindex="-1"></a>******</span>
<span id="cb3-532"><a href="#cb3-532" aria-hidden="true" tabindex="-1"></a>  Step 1.  Grow $B_1$ randomized trees with $\mtry=\lfloor \sqrt{d} \rfloor$ and $\Nmin=1$ </span>
<span id="cb3-533"><a href="#cb3-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-534"><a href="#cb3-534" aria-hidden="true" tabindex="-1"></a>  Step 2. For each covariate $j \in \left<span class="sc">\{</span> 1, \ldots, d \right<span class="sc">\}</span>$, count $v_j$ the number of times</span>
<span id="cb3-535"><a href="#cb3-535" aria-hidden="true" tabindex="-1"></a>   $X_j$ has been used during the paths followed by $\xs$</span>
<span id="cb3-536"><a href="#cb3-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-537"><a href="#cb3-537" aria-hidden="true" tabindex="-1"></a>  Step 3.  Compute the resampling probability of the covariate $j$ relative to $\xs$ as</span>
<span id="cb3-538"><a href="#cb3-538" aria-hidden="true" tabindex="-1"></a>    $p_j=\frac{v_j}{\sum_{\ell=1}^d v_\ell}$, for $j \in \left<span class="sc">\{</span> 1, \ldots, d \right<span class="sc">\}</span>$</span>
<span id="cb3-539"><a href="#cb3-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-540"><a href="#cb3-540" aria-hidden="true" tabindex="-1"></a>  Step 4. Train a usual RF of size $B_2$ with covariate resampling probabilities </span>
<span id="cb3-541"><a href="#cb3-541" aria-hidden="true" tabindex="-1"></a>   $p_1, \ldots, p_d$ at each internal node and deduce the prediction for $\xs$</span>
<span id="cb3-542"><a href="#cb3-542" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb3-543"><a href="#cb3-543" aria-hidden="true" tabindex="-1"></a>******</span>
<span id="cb3-544"><a href="#cb3-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-545"><a href="#cb3-545" aria-hidden="true" tabindex="-1"></a>Some approaches dealing with covariate weighting have been studied in a non-local framework. @amaratunga:etal:2008 propose the enriched random forests in an extremely noisy feature space, where covariate sampling is modified using global weights. @maudes:etal:2012, with their random feature weights approach,</span>
<span id="cb3-546"><a href="#cb3-546" aria-hidden="true" tabindex="-1"></a>investigate the use of non-uniform sampling of covariates, changing for each tree.</span>
<span id="cb3-547"><a href="#cb3-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-548"><a href="#cb3-548" aria-hidden="true" tabindex="-1"></a><span class="fu"># Local weighting of votes {#sec-treeWeights}</span></span>
<span id="cb3-549"><a href="#cb3-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-550"><a href="#cb3-550" aria-hidden="true" tabindex="-1"></a>The final prediction of a classical RF is the majority vote of all trees, hence they all have equal weight.</span>
<span id="cb3-551"><a href="#cb3-551" aria-hidden="true" tabindex="-1"></a>However a given tree might provide very good predictions on some test instances, but perform very poorly on others.</span>
<span id="cb3-552"><a href="#cb3-552" aria-hidden="true" tabindex="-1"></a>This is why a strategy for building local random forests is based on weighting tree predictions depending on their ability to correctly predict instances similar to $\xs$. Majority vote is hence replaced with locally weighted vote.</span>
<span id="cb3-553"><a href="#cb3-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-554"><a href="#cb3-554" aria-hidden="true" tabindex="-1"></a>In the instance-based framework, @robnik:2004; @tsymbal:etal:2006 and then @zhang:etal:2013 investigate this idea. Given a test instance $\xs$, $\kappa$ neighbors are selected based on the proximity measure introduced in @breiman:2001, (i.e. the average number of times two data end in the same leaf) to compute a per-tree error score. These scores are further used to select and weight trees and to provide a final weighted-vote prediction.</span>
<span id="cb3-555"><a href="#cb3-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-556"><a href="#cb3-556" aria-hidden="true" tabindex="-1"></a><span class="fu">## Dynamic voting and selection {#sec-dynamicVoting}</span></span>
<span id="cb3-557"><a href="#cb3-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-558"><a href="#cb3-558" aria-hidden="true" tabindex="-1"></a>This section describes the methodology of @tsymbal:etal:2006, called Dynamic Voting with Selection Random Forest (DVSRF). </span>
<span id="cb3-559"><a href="#cb3-559" aria-hidden="true" tabindex="-1"></a>A first RF is trained thanks to which $\kappa$ nearest neighbors to $\xs$ are selected.</span>
<span id="cb3-560"><a href="#cb3-560" aria-hidden="true" tabindex="-1"></a>The quality of the $b$-th tree toward $\xs$ is then evaluated as the average margins of the out-of-bag $\kappa$ instances, weighted by proximities, i.e.   </span>
<span id="cb3-561"><a href="#cb3-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-562"><a href="#cb3-562" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-563"><a href="#cb3-563" aria-hidden="true" tabindex="-1"></a>    w_b(\xs) = \frac{ \sum_{i=1}^\kappa \mathbf{1}<span class="sc">\{</span>x\idxi \in \text{OOB}_b\} \, \sigma(\xs, x\idxi) \, \text{mr}_b(x\idxi) }{\sum_{\ell=1}^\kappa \mathbf{1}<span class="sc">\{</span>x^{(\ell)} \in \text{OOB}_b<span class="sc">\}</span> \, \sigma(\xs, x^{(\ell)}) } \, ,</span>
<span id="cb3-564"><a href="#cb3-564" aria-hidden="true" tabindex="-1"></a>$${#eq-weightsTree}</span>
<span id="cb3-565"><a href="#cb3-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-566"><a href="#cb3-566" aria-hidden="true" tabindex="-1"></a>where $\text{OOB}_b$ is the set of out-of-bag data for the $b$-th tree, $\sigma(\xs, x\idxi)$ is the proximity measure provided by the RF, to the power of $3$, and the margin function $\text{mr}_b(x\idxi)$ is equal to $1$ if the $b$-th tree predicts $y\idxi$ correctly, $-1$ otherwise.</span>
<span id="cb3-567"><a href="#cb3-567" aria-hidden="true" tabindex="-1"></a>Weights @eq-weightsTree are then normalized to be positive and to sum to one.</span>
<span id="cb3-568"><a href="#cb3-568" aria-hidden="true" tabindex="-1"></a>Finally, the prediction for $\xs$ is computed using the majority class of the weighted tree vote proportions</span>
<span id="cb3-569"><a href="#cb3-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-570"><a href="#cb3-570" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-571"><a href="#cb3-571" aria-hidden="true" tabindex="-1"></a>    \hat{y}^* = \argmax_{1\leq k \leq K} p_{\text{DVS},k} \;\;\;\;\;\; </span>
<span id="cb3-572"><a href="#cb3-572" aria-hidden="true" tabindex="-1"></a>$${#eq-predDVSRF}</span>
<span id="cb3-573"><a href="#cb3-573" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-574"><a href="#cb3-574" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-575"><a href="#cb3-575" aria-hidden="true" tabindex="-1"></a>\text{where} \;\;\;\;\;\; p_{\text{DVS},k} = \frac{\sum_{b=1}^B  \mathbf{1}<span class="sc">\{</span> \hat{y}^*_b=k \} w_b(\xs)}{\sum_{\ell=1}^B w_\ell(\xs)}</span>
<span id="cb3-576"><a href="#cb3-576" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-577"><a href="#cb3-577" aria-hidden="true" tabindex="-1"></a>and $\hat{y}^*_b$ denotes the original prediction of the $b$-th tree for $\xs$. <span class="sc">\\</span></span>
<span id="cb3-578"><a href="#cb3-578" aria-hidden="true" tabindex="-1"></a>A predefined number of trees denoted $B_\text{sel}$ (usually half of $B$),</span>
<span id="cb3-579"><a href="#cb3-579" aria-hidden="true" tabindex="-1"></a>carrying the highest weights, can be selected and used for the final</span>
<span id="cb3-580"><a href="#cb3-580" aria-hidden="true" tabindex="-1"></a>prediction, modifying weighted predictions @eq-predDVSRF accordingly.</span>
<span id="cb3-581"><a href="#cb3-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-582"><a href="#cb3-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-583"><a href="#cb3-583" aria-hidden="true" tabindex="-1"></a><span class="fu">## Kernel weighted voting {#sec-kernelVoting}</span></span>
<span id="cb3-584"><a href="#cb3-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-585"><a href="#cb3-585" aria-hidden="true" tabindex="-1"></a>In the same spirit, we investigate the use of a multidimensional kernel as</span>
<span id="cb3-586"><a href="#cb3-586" aria-hidden="true" tabindex="-1"></a>similarity measure (presented in @sec-localKernelMultiDim and we replace the margin function by the simpler alternative $\mathbf{1}<span class="sc">\{</span>\hat{y}\idxi_b=y\idxi<span class="sc">\}</span>$ indicating whether the $b$-th tree prediction for $x\idxi$, denoted $\hat{y}\idxi_b$, is correct or not.</span>
<span id="cb3-587"><a href="#cb3-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-588"><a href="#cb3-588" aria-hidden="true" tabindex="-1"></a>Using the same notations as above, the $b$-th tree weight is hence computed in the following way:</span>
<span id="cb3-589"><a href="#cb3-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-590"><a href="#cb3-590" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb3-591"><a href="#cb3-591" aria-hidden="true" tabindex="-1"></a>w_b(\xs) = \frac{ \sum_{i=1}^N \mathbf{1}<span class="sc">\{</span>x\idxi \in \text{OOB}_b\} \, K_V(x^{(i)}-x^*) \, \mathbf{1} \{\hat{y}\idxi_b=y\idxi\} }{\sum_{\ell=1}^N \mathbf{1}<span class="sc">\{</span>x^{(\ell)} \in \text{OOB}_b<span class="sc">\}</span> \, K_V(x^{(\ell)}-x^*)}.</span>
<span id="cb3-592"><a href="#cb3-592" aria-hidden="true" tabindex="-1"></a>$${#eq-weightsKernelTree}</span>
<span id="cb3-593"><a href="#cb3-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-594"><a href="#cb3-594" aria-hidden="true" tabindex="-1"></a>All $N$ labeled data are used for the weight computation, their importance being measured by the kernel. $\alpha$ is again set to $1$ and tree selection is not performed.</span>
<span id="cb3-595"><a href="#cb3-595" aria-hidden="true" tabindex="-1"></a>In the following this proposal is denoted as KV-RF (for kernel voting - random forest).</span>
<span id="cb3-596"><a href="#cb3-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-597"><a href="#cb3-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-598"><a href="#cb3-598" aria-hidden="true" tabindex="-1"></a><span class="fu"># Numerical experiments {#sec-examples}</span></span>
<span id="cb3-599"><a href="#cb3-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-600"><a href="#cb3-600" aria-hidden="true" tabindex="-1"></a>In this section, we compare the previously presented methods -- summarized below -- on two (simulated) Gaussian mixtures examples and a population genetics example.</span>
<span id="cb3-601"><a href="#cb3-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-602"><a href="#cb3-602" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>CSRF -  Case-specific RF - @sec-weightingIndividuals</span>
<span id="cb3-603"><a href="#cb3-603" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>NN-RF -  Nearest-neighbors RF - @sec-nearest-neighbours</span>
<span id="cb3-604"><a href="#cb3-604" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>LVI-RF -  Local variable importance RF - @sec-weightingCovariates</span>
<span id="cb3-605"><a href="#cb3-605" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>DVSRF -  Dynamic voting with selection RF - @sec-dynamicVoting </span>
<span id="cb3-606"><a href="#cb3-606" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>KV-RF -  Kernel voting RF - @sec-kernelVoting</span>
<span id="cb3-607"><a href="#cb3-607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-608"><a href="#cb3-608" aria-hidden="true" tabindex="-1"></a>Methods are run ten times on the same test data set. The average and standard deviation of the ten resulting misclassification error rates, per method, are reported as a measure of performance. Note that in order to recover the predictions for the whole test table, each local algorithm is reapplied to each test data.</span>
<span id="cb3-609"><a href="#cb3-609" aria-hidden="true" tabindex="-1"></a>The  first two Gaussian examples have the advantage of being simple enough to compute the Bayes classifier which gives the optimal error rate.</span>
<span id="cb3-610"><a href="#cb3-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-611"><a href="#cb3-611" aria-hidden="true" tabindex="-1"></a>The lazy decision random forest approach presented in @sec-lazyDT as well</span>
<span id="cb3-612"><a href="#cb3-612" aria-hidden="true" tabindex="-1"></a>as both approaches involving kernels (unidimensional kernels and</span>
<span id="cb3-613"><a href="#cb3-613" aria-hidden="true" tabindex="-1"></a>multidimension kernel presented in @sec-localKernel and</span>
<span id="cb3-614"><a href="#cb3-614" aria-hidden="true" tabindex="-1"></a>@sec-localKernelMultiDim were implemented and compared on a lower dimensional</span>
<span id="cb3-615"><a href="#cb3-615" aria-hidden="true" tabindex="-1"></a>simulation study (second Gaussian examples with only 500 test data and 4</span>
<span id="cb3-616"><a href="#cb3-616" aria-hidden="true" tabindex="-1"></a>replications, results presented in @sec-gaussianExampleUnbalanced but were dropped of the final comparison due to high computational cost despite poor results.</span>
<span id="cb3-617"><a href="#cb3-617" aria-hidden="true" tabindex="-1"></a>Indeed, localizing trees with identical criterion should be faster, but with modified criterion (information gain or kernel-based Gini criterion),  they require the computation of one weight per training data in the leaf, which can be very burdensome.  This is particularly true since given our first results, we have not optimized our codes to allow faster computations.</span>
<span id="cb3-618"><a href="#cb3-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-619"><a href="#cb3-619" aria-hidden="true" tabindex="-1"></a>The random forests are built using the default parameters, i.e. trees are maximal ($\Nmin=1$), and the covariate sampling parameter is $\mtry=\lfloor \sqrt{d} \rfloor$. Moreover, each forest is made of $100$ trees, meaning CSRF and LVI-RF use a total of $200$ trees. Additional/different tuning parameters are specified in the displayed result tables.</span>
<span id="cb3-620"><a href="#cb3-620" aria-hidden="true" tabindex="-1"></a>All the methods involve classic RF, we use the R package *ranger* <span class="co">[</span><span class="ot">@wright:ziegler:2017</span><span class="co">]</span> for their construction. </span>
<span id="cb3-621"><a href="#cb3-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-622"><a href="#cb3-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-623"><a href="#cb3-623" aria-hidden="true" tabindex="-1"></a><span class="fu">## Balanced Gaussian mixture example {#sec-gaussianExample}</span></span>
<span id="cb3-624"><a href="#cb3-624" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-625"><a href="#cb3-625" aria-hidden="true" tabindex="-1"></a>We consider 40-dimensional data from four classes $(1, 2, 3, 4)$. </span>
<span id="cb3-626"><a href="#cb3-626" aria-hidden="true" tabindex="-1"></a>The classes have equal weight: $p_1=p_2=p_3=p_4=1/4$.</span>
<span id="cb3-627"><a href="#cb3-627" aria-hidden="true" tabindex="-1"></a>The data are generated from 20-dimensional Gaussian distributions and $20$ noise explanatory variables are added, simulated according to a uniform distribution $\mathcal{U}_{<span class="co">[</span><span class="ot">0;10,000</span><span class="co">]</span>}$. We consider two training data sets of sizes $3,000$ and $10,000$, both sampled among the 4 classes with equal probabilities. In both cases, $5,000$ simulations are used as testing data set, also sampled equally among the 4 models.</span>
<span id="cb3-628"><a href="#cb3-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-629"><a href="#cb3-629" aria-hidden="true" tabindex="-1"></a>The parameters associated to the $20$-multidimensional Gaussian distribution are</span>
<span id="cb3-630"><a href="#cb3-630" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-631"><a href="#cb3-631" aria-hidden="true" tabindex="-1"></a>    \mu_1 &amp;=    \left(0.8, 3, 1, 2.5,   \ldots,1, 2.5   \right)^\top,       &amp;</span>
<span id="cb3-632"><a href="#cb3-632" aria-hidden="true" tabindex="-1"></a>    \mu_2 &amp;=    \left(3.2, 3, 2.5, 2.5, \ldots, 2.5, 2.5    \right)^\top,   <span class="sc">\\</span></span>
<span id="cb3-633"><a href="#cb3-633" aria-hidden="true" tabindex="-1"></a>    \mu_3 &amp;=    \left(2, 1, 2, 2.3, \ldots, 2, 2.3  \right)^\top,           &amp;</span>
<span id="cb3-634"><a href="#cb3-634" aria-hidden="true" tabindex="-1"></a>    \mu_4 &amp;=    \left(2, 0, 2, 1.8, \ldots, 2, 1.8  \right)^\top,           <span class="sc">\\</span></span>
<span id="cb3-635"><a href="#cb3-635" aria-hidden="true" tabindex="-1"></a>    \Sigma_1 &amp;= \diag(3, 3, 3, 1, \ldots, 3, 1),        &amp;</span>
<span id="cb3-636"><a href="#cb3-636" aria-hidden="true" tabindex="-1"></a>    \Sigma_2 &amp;= \diag(3, 3, 3, 5, \ldots, 3, 5),        <span class="sc">\\</span></span>
<span id="cb3-637"><a href="#cb3-637" aria-hidden="true" tabindex="-1"></a>    \Sigma_3 &amp;= \diag(4, 1, 4, 1, \ldots, 4, 1),        &amp;</span>
<span id="cb3-638"><a href="#cb3-638" aria-hidden="true" tabindex="-1"></a>    \Sigma_4 &amp;= \diag(2.5, 1, 2.5, 1, \ldots, 2.5, 1).</span>
<span id="cb3-639"><a href="#cb3-639" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-640"><a href="#cb3-640" aria-hidden="true" tabindex="-1"></a>The first two dimensions are the most relevant for discriminating between the</span>
<span id="cb3-641"><a href="#cb3-641" aria-hidden="true" tabindex="-1"></a>four classes. They are represented in @fig-gaussEq. Indeed, although the remaining ones can provide information to identify the class labels, they are more overlapping with each others and hence less informative.</span>
<span id="cb3-642"><a href="#cb3-642" aria-hidden="true" tabindex="-1"></a>We also consider a higher dimensional setting in which we add $100$ additional</span>
<span id="cb3-643"><a href="#cb3-643" aria-hidden="true" tabindex="-1"></a>noise variables (sampled as uniforms on $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$) for which we reproduce the</span>
<span id="cb3-644"><a href="#cb3-644" aria-hidden="true" tabindex="-1"></a>same training / test combinations. The results are presented in @tbl-gaussEqNoise10 for $10,000$ training data.</span>
<span id="cb3-645"><a href="#cb3-645" aria-hidden="true" tabindex="-1"></a>In both scenarios, using only $3,000$ training data increased the error rates of about $2$\% for each method, but did not change the comparison.</span>
<span id="cb3-646"><a href="#cb3-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-649"><a href="#cb3-649" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-650"><a href="#cb3-650" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.height: 4</span></span>
<span id="cb3-651"><a href="#cb3-651" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.width: 4</span></span>
<span id="cb3-652"><a href="#cb3-652" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-gaussEq</span></span>
<span id="cb3-653"><a href="#cb3-653" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-654"><a href="#cb3-654" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-655"><a href="#cb3-655" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "First Gaussian example: two first explanatory variables $X_1$ and $X_2$ ;    colors indicate the class labels (1-sky blue, 2-purple, 3-sand, 4-dark green)."</span></span>
<span id="cb3-656"><a href="#cb3-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-657"><a href="#cb3-657" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb3-658"><a href="#cb3-658" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mvtnorm)</span>
<span id="cb3-659"><a href="#cb3-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-660"><a href="#cb3-660" aria-hidden="true" tabindex="-1"></a><span class="co"># Model probabilities (4 balanced classes)</span></span>
<span id="cb3-661"><a href="#cb3-661" aria-hidden="true" tabindex="-1"></a>pi0 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-662"><a href="#cb3-662" aria-hidden="true" tabindex="-1"></a>pi1 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-663"><a href="#cb3-663" aria-hidden="true" tabindex="-1"></a>pi2 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-664"><a href="#cb3-664" aria-hidden="true" tabindex="-1"></a>pi3 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-665"><a href="#cb3-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-666"><a href="#cb3-666" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian dimension</span></span>
<span id="cb3-667"><a href="#cb3-667" aria-hidden="true" tabindex="-1"></a>l <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb3-668"><a href="#cb3-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-669"><a href="#cb3-669" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian parameters</span></span>
<span id="cb3-670"><a href="#cb3-670" aria-hidden="true" tabindex="-1"></a>mu0 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="fl">0.8</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="fl">2.5</span>), l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma0 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) )</span>
<span id="cb3-671"><a href="#cb3-671" aria-hidden="true" tabindex="-1"></a>mu1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="fl">3.2</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fl">2.5</span>,<span class="fl">2.5</span>), l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma1 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) )</span>
<span id="cb3-672"><a href="#cb3-672" aria-hidden="true" tabindex="-1"></a>mu2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="fl">2.3</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma2 <span class="ot">&lt;-</span> <span class="fu">diag</span>( (<span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2</span>) ) )</span>
<span id="cb3-673"><a href="#cb3-673" aria-hidden="true" tabindex="-1"></a>mu3 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">0</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="fl">1.8</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma3 <span class="ot">&lt;-</span> <span class="fu">diag</span>( (<span class="fu">rep</span>(<span class="fu">c</span>(<span class="fl">2.5</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2</span>) ) )</span>
<span id="cb3-674"><a href="#cb3-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-675"><a href="#cb3-675" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of training data</span></span>
<span id="cb3-676"><a href="#cb3-676" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span><span class="dv">3000</span> <span class="co"># only 3000 to keep figure meaningful</span></span>
<span id="cb3-677"><a href="#cb3-677" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample class label</span></span>
<span id="cb3-678"><a href="#cb3-678" aria-hidden="true" tabindex="-1"></a>classe <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(pi0,pi1,pi2,pi3))</span>
<span id="cb3-679"><a href="#cb3-679" aria-hidden="true" tabindex="-1"></a>classe <span class="ot">&lt;-</span> <span class="fu">sort</span>(classe)</span>
<span id="cb3-680"><a href="#cb3-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-681"><a href="#cb3-681" aria-hidden="true" tabindex="-1"></a>couleur <span class="ot">&lt;-</span> <span class="fu">rep</span>(safe_colorblind_palette[<span class="dv">1</span>], n)</span>
<span id="cb3-682"><a href="#cb3-682" aria-hidden="true" tabindex="-1"></a>couleur[classe<span class="sc">==</span><span class="dv">1</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">2</span>]</span>
<span id="cb3-683"><a href="#cb3-683" aria-hidden="true" tabindex="-1"></a>couleur[classe<span class="sc">==</span><span class="dv">2</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">3</span>]</span>
<span id="cb3-684"><a href="#cb3-684" aria-hidden="true" tabindex="-1"></a>couleur[classe<span class="sc">==</span><span class="dv">3</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">4</span>]</span>
<span id="cb3-685"><a href="#cb3-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-686"><a href="#cb3-686" aria-hidden="true" tabindex="-1"></a>n0 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">0</span>)</span>
<span id="cb3-687"><a href="#cb3-687" aria-hidden="true" tabindex="-1"></a>n1 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">1</span>)</span>
<span id="cb3-688"><a href="#cb3-688" aria-hidden="true" tabindex="-1"></a>n2 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">2</span>)</span>
<span id="cb3-689"><a href="#cb3-689" aria-hidden="true" tabindex="-1"></a>n3 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">3</span>)</span>
<span id="cb3-690"><a href="#cb3-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-691"><a href="#cb3-691" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample from the Gaussians</span></span>
<span id="cb3-692"><a href="#cb3-692" aria-hidden="true" tabindex="-1"></a>x.train <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">rmvnorm</span>(n0, mu0, Sigma0),</span>
<span id="cb3-693"><a href="#cb3-693" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">rmvnorm</span>(n1, mu1, Sigma1),</span>
<span id="cb3-694"><a href="#cb3-694" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">rmvnorm</span>(n2, mu2, Sigma2),</span>
<span id="cb3-695"><a href="#cb3-695" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">rmvnorm</span>(n3, mu3, Sigma3))</span>
<span id="cb3-696"><a href="#cb3-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-697"><a href="#cb3-697" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph generation</span></span>
<span id="cb3-698"><a href="#cb3-698" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x.train[,<span class="dv">1</span>], x.train[,<span class="dv">2</span>], <span class="at">col=</span>couleur,<span class="at">xlab=</span><span class="st">"X1"</span>,<span class="at">ylab=</span><span class="st">"X2"</span>,<span class="at">pch=</span><span class="dv">8</span>,<span class="at">cex=</span><span class="fl">0.8</span>)</span>
<span id="cb3-699"><a href="#cb3-699" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-700"><a href="#cb3-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-701"><a href="#cb3-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-702"><a href="#cb3-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-703"><a href="#cb3-703" aria-hidden="true" tabindex="-1"></a><span class="in">```{r gaussEq10} </span></span>
<span id="cb3-704"><a href="#cb3-704" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: tbl-gaussEqNoise10</span></span>
<span id="cb3-705"><a href="#cb3-705" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb3-706"><a href="#cb3-706" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb3-707"><a href="#cb3-707" aria-hidden="true" tabindex="-1"></a><span class="in">#| tbl-cap: "First Gaussian example: prediction error rate (percentage), with 10000 training data. With 20 variables (columns 3 and 4), and with 100 additional noise variables (columns 5 and 6)"</span></span>
<span id="cb3-708"><a href="#cb3-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-709"><a href="#cb3-709" aria-hidden="true" tabindex="-1"></a><span class="in">library(xtable)</span></span>
<span id="cb3-710"><a href="#cb3-710" aria-hidden="true" tabindex="-1"></a><span class="in">resTOT&lt;-read.table("Gaussian-Balanced-No-Noise/Example-Gaussian-Balanced-No-Noise-Res-10000.txt",header=T)</span></span>
<span id="cb3-711"><a href="#cb3-711" aria-hidden="true" tabindex="-1"></a><span class="in">resTOT&lt;-100*resTOT</span></span>
<span id="cb3-712"><a href="#cb3-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-713"><a href="#cb3-713" aria-hidden="true" tabindex="-1"></a><span class="in">Identifier&lt;-c("Bayes classifier","Bagged CARTs","Random forest","LVI-RF","CSRF","CSRF","CSRF","CSRF","CSRF","CSRF","DVSRF","DVSRF","KV-RF","KV-RF","KV-RF","KV-RF","NN-RF","NN-RF","NN-RF")</span></span>
<span id="cb3-714"><a href="#cb3-714" aria-hidden="true" tabindex="-1"></a><span class="in">Characteristics&lt;-c("","","","","Nmin=5","Nmin=10","Nmin=50","Nmin=150","Nmin=250","Nmin=350","k=3000,Bsel=100","k=3000,Bsel=50","alpha=1","alpha=0.75","alpha=0.5","alpha=0.25", "k=1000","k=1500","k=2500")</span></span>
<span id="cb3-715"><a href="#cb3-715" aria-hidden="true" tabindex="-1"></a><span class="in">Table=cbind(Identifier,Characteristics,apply(resTOT,2,mean),paste("(",round(apply(resTOT,2,sd),3),")",sep=""))</span></span>
<span id="cb3-716"><a href="#cb3-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-717"><a href="#cb3-717" aria-hidden="true" tabindex="-1"></a><span class="in">TableOrdered=Table[c(1:3,5:10,17:19,4,11:16),]</span></span>
<span id="cb3-718"><a href="#cb3-718" aria-hidden="true" tabindex="-1"></a><span class="in">colnames(TableOrdered)=c("Method","Parameters","Error rate","(sd)")</span></span>
<span id="cb3-719"><a href="#cb3-719" aria-hidden="true" tabindex="-1"></a><span class="in">rownames(TableOrdered)=NULL</span></span>
<span id="cb3-720"><a href="#cb3-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-721"><a href="#cb3-721" aria-hidden="true" tabindex="-1"></a><span class="in">#kableExtra::kable(TableOrdered,caption= "First Gaussian example: prediction error rate (percentage), with 10000 training data",booktabs=T,label= "gaussEq10",row.names=NA)</span></span>
<span id="cb3-722"><a href="#cb3-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-723"><a href="#cb3-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-724"><a href="#cb3-724" aria-hidden="true" tabindex="-1"></a><span class="in">resTOT&lt;-read.table("Gaussian-Balanced-With-Noise/Example-Gaussian-Balanced-With-Noise-Res-10000.txt",header=T)</span></span>
<span id="cb3-725"><a href="#cb3-725" aria-hidden="true" tabindex="-1"></a><span class="in">resTOT&lt;-100*resTOT</span></span>
<span id="cb3-726"><a href="#cb3-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-727"><a href="#cb3-727" aria-hidden="true" tabindex="-1"></a><span class="in">Identifier&lt;-c("Bayes classifier","Bagged CARTs","Random forest","LVI-RF","CSRF","CSRF","CSRF","CSRF","CSRF","CSRF","DVSRF","DVSRF","KV-RF","KV-RF","KV-RF","KV-RF","NN-RF","NN-RF","NN-RF")</span></span>
<span id="cb3-728"><a href="#cb3-728" aria-hidden="true" tabindex="-1"></a><span class="in">Characteristics&lt;-c("","","","","Nmin=5","Nmin=10","Nmin=50","Nmin=150","Nmin=250","Nmin=350","k=3000,Bsel=100","k=3000,Bsel=50","alpha=1","alpha=0.75","alpha=0.5","alpha=0.25", "k=1000","k=1500","k=2500")</span></span>
<span id="cb3-729"><a href="#cb3-729" aria-hidden="true" tabindex="-1"></a><span class="in">Table=cbind(Identifier,Characteristics,apply(resTOT,2,mean),paste("(",round(apply(resTOT,2,sd),3),")",sep=""))</span></span>
<span id="cb3-730"><a href="#cb3-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-731"><a href="#cb3-731" aria-hidden="true" tabindex="-1"></a><span class="in">TableOrdered2=Table[c(1:3,5:10,17:19,4,11:16),]</span></span>
<span id="cb3-732"><a href="#cb3-732" aria-hidden="true" tabindex="-1"></a><span class="in">colnames(TableOrdered2)=c("Method","Parameters","Error rate","(sd)")</span></span>
<span id="cb3-733"><a href="#cb3-733" aria-hidden="true" tabindex="-1"></a><span class="in">rownames(TableOrdered2)=NULL</span></span>
<span id="cb3-734"><a href="#cb3-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-735"><a href="#cb3-735" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-736"><a href="#cb3-736" aria-hidden="true" tabindex="-1"></a><span class="in">Table2=cbind(TableOrdered,TableOrdered2[,3:4])</span></span>
<span id="cb3-737"><a href="#cb3-737" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-738"><a href="#cb3-738" aria-hidden="true" tabindex="-1"></a><span class="in">kableExtra::kable(Table2, row.names=NA)</span></span>
<span id="cb3-739"><a href="#cb3-739" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-740"><a href="#cb3-740" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-741"><a href="#cb3-741" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-742"><a href="#cb3-742" aria-hidden="true" tabindex="-1"></a>The only method that manages to outbeat a standard random forest is the Nearest-Neighbors RF (about 1\% of error rate), while all other methods have similar or worse results than RF.</span>
<span id="cb3-743"><a href="#cb3-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-744"><a href="#cb3-744" aria-hidden="true" tabindex="-1"></a><span class="fu">## Unbalanced Gaussian mixture example {#sec-gaussianExampleUnbalanced}</span></span>
<span id="cb3-745"><a href="#cb3-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-746"><a href="#cb3-746" aria-hidden="true" tabindex="-1"></a>We still consider four classes but their model prior probabilities are</span>
<span id="cb3-747"><a href="#cb3-747" aria-hidden="true" tabindex="-1"></a>$p_1=p_2=0.4$ and $p_3=p_4=0.1$. Once again, we considered two training data sets, one made of $3,000$ samples, the other of $10,000$ samples, drawn among the four classes according to these probabilities.</span>
<span id="cb3-748"><a href="#cb3-748" aria-hidden="true" tabindex="-1"></a>The testing set considers $5,000$ data equally sampled among the two classes 3 and 4, the least frequent ones.</span>
<span id="cb3-749"><a href="#cb3-749" aria-hidden="true" tabindex="-1"></a>In this example we therefore measure the prediction accuracy of low-frequency data.</span>
<span id="cb3-750"><a href="#cb3-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-751"><a href="#cb3-751" aria-hidden="true" tabindex="-1"></a>The first two covariates are still the most important ones, </span>
<span id="cb3-752"><a href="#cb3-752" aria-hidden="true" tabindex="-1"></a>however we slightly modified the Gaussian parameters </span>
<span id="cb3-753"><a href="#cb3-753" aria-hidden="true" tabindex="-1"></a>(the first two diagonal terms for $\Sigma_1$ and $\Sigma_2$ are now 2 and 1) to induce as best split rule </span>
<span id="cb3-754"><a href="#cb3-754" aria-hidden="true" tabindex="-1"></a>for a CART: $X_1\approx2$. This example hence becomes an illustration of the fragmentation problem we mentioned </span>
<span id="cb3-755"><a href="#cb3-755" aria-hidden="true" tabindex="-1"></a>earlier (@fig-4Unif). Indeed, the first cut produced by the eager RF algorithm -- if this covariate is sampled -- </span>
<span id="cb3-756"><a href="#cb3-756" aria-hidden="true" tabindex="-1"></a>will split the elements labeled 3 and 4 in half (at $X_1\approx2$). It implies</span>
<span id="cb3-757"><a href="#cb3-757" aria-hidden="true" tabindex="-1"></a>the loss of some potentially relevant training data to predict those two</span>
<span id="cb3-758"><a href="#cb3-758" aria-hidden="true" tabindex="-1"></a>classes. We hope local approaches can handle such an example which also</span>
<span id="cb3-759"><a href="#cb3-759" aria-hidden="true" tabindex="-1"></a>contains very unbalanced classes proportions, see @fig-gaussDisp. Once again</span>
<span id="cb3-760"><a href="#cb3-760" aria-hidden="true" tabindex="-1"></a>we also consider the same scenario where we add $100$ additional noise</span>
<span id="cb3-761"><a href="#cb3-761" aria-hidden="true" tabindex="-1"></a>variables drawn from uniform distributions on $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. The results are</span>
<span id="cb3-762"><a href="#cb3-762" aria-hidden="true" tabindex="-1"></a>presented in @tbl-gaussUnbNoise10. Once again, only the results for $10,000$ training data are shown as the methods comparison is similar for $3,000$ data, at the price of a higher error rate (about 2\%).</span>
<span id="cb3-763"><a href="#cb3-763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-766"><a href="#cb3-766" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-767"><a href="#cb3-767" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.height: 4</span></span>
<span id="cb3-768"><a href="#cb3-768" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.width: 4</span></span>
<span id="cb3-769"><a href="#cb3-769" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-gaussDisp</span></span>
<span id="cb3-770"><a href="#cb3-770" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-771"><a href="#cb3-771" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-772"><a href="#cb3-772" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Second Gaussian example: two first explanatory variables $X_1$ and $X_2$ ;    colors indicate the classes (1-sky blue, 2-purple, 3-sand, 4-dark green)."</span></span>
<span id="cb3-773"><a href="#cb3-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-774"><a href="#cb3-774" aria-hidden="true" tabindex="-1"></a><span class="co"># Model probabilities (4 balanced classes)</span></span>
<span id="cb3-775"><a href="#cb3-775" aria-hidden="true" tabindex="-1"></a>pi0 <span class="ot">&lt;-</span> <span class="fl">0.40</span></span>
<span id="cb3-776"><a href="#cb3-776" aria-hidden="true" tabindex="-1"></a>pi1 <span class="ot">&lt;-</span> <span class="fl">0.40</span></span>
<span id="cb3-777"><a href="#cb3-777" aria-hidden="true" tabindex="-1"></a>pi2 <span class="ot">&lt;-</span> <span class="fl">0.10</span></span>
<span id="cb3-778"><a href="#cb3-778" aria-hidden="true" tabindex="-1"></a>pi3 <span class="ot">&lt;-</span> <span class="fl">0.10</span></span>
<span id="cb3-779"><a href="#cb3-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-780"><a href="#cb3-780" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian dimension</span></span>
<span id="cb3-781"><a href="#cb3-781" aria-hidden="true" tabindex="-1"></a>l <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb3-782"><a href="#cb3-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-783"><a href="#cb3-783" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian parameters</span></span>
<span id="cb3-784"><a href="#cb3-784" aria-hidden="true" tabindex="-1"></a>mu0 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="fl">0.8</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="fl">2.5</span>), l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma0 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) )</span>
<span id="cb3-785"><a href="#cb3-785" aria-hidden="true" tabindex="-1"></a>mu1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="fl">3.2</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fl">2.5</span>,<span class="fl">2.5</span>), l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma1 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) )</span>
<span id="cb3-786"><a href="#cb3-786" aria-hidden="true" tabindex="-1"></a>mu2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="fl">2.3</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma2 <span class="ot">&lt;-</span> <span class="fu">diag</span>( (<span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2</span>) ) )</span>
<span id="cb3-787"><a href="#cb3-787" aria-hidden="true" tabindex="-1"></a>mu3 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">0</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="fl">1.8</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) ; Sigma3 <span class="ot">&lt;-</span> <span class="fu">diag</span>( (<span class="fu">rep</span>(<span class="fu">c</span>(<span class="fl">2.5</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2</span>) ) )</span>
<span id="cb3-788"><a href="#cb3-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-789"><a href="#cb3-789" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of training data</span></span>
<span id="cb3-790"><a href="#cb3-790" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">3000</span></span>
<span id="cb3-791"><a href="#cb3-791" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample class label</span></span>
<span id="cb3-792"><a href="#cb3-792" aria-hidden="true" tabindex="-1"></a>classe <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(pi0,pi1,pi2,pi3))</span>
<span id="cb3-793"><a href="#cb3-793" aria-hidden="true" tabindex="-1"></a>classe <span class="ot">&lt;-</span> <span class="fu">sort</span>(classe)</span>
<span id="cb3-794"><a href="#cb3-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-795"><a href="#cb3-795" aria-hidden="true" tabindex="-1"></a>couleur <span class="ot">&lt;-</span> <span class="fu">rep</span>(safe_colorblind_palette[<span class="dv">1</span>], n)</span>
<span id="cb3-796"><a href="#cb3-796" aria-hidden="true" tabindex="-1"></a>couleur[classe<span class="sc">==</span><span class="dv">1</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">2</span>]</span>
<span id="cb3-797"><a href="#cb3-797" aria-hidden="true" tabindex="-1"></a>couleur[classe<span class="sc">==</span><span class="dv">2</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">3</span>]</span>
<span id="cb3-798"><a href="#cb3-798" aria-hidden="true" tabindex="-1"></a>couleur[classe<span class="sc">==</span><span class="dv">3</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">4</span>]</span>
<span id="cb3-799"><a href="#cb3-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-800"><a href="#cb3-800" aria-hidden="true" tabindex="-1"></a>n0 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">0</span>)</span>
<span id="cb3-801"><a href="#cb3-801" aria-hidden="true" tabindex="-1"></a>n1 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">1</span>)</span>
<span id="cb3-802"><a href="#cb3-802" aria-hidden="true" tabindex="-1"></a>n2 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">2</span>)</span>
<span id="cb3-803"><a href="#cb3-803" aria-hidden="true" tabindex="-1"></a>n3 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">3</span>)</span>
<span id="cb3-804"><a href="#cb3-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-805"><a href="#cb3-805" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample from the Gaussians</span></span>
<span id="cb3-806"><a href="#cb3-806" aria-hidden="true" tabindex="-1"></a>x.train <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">rmvnorm</span>(n0, mu0, Sigma0),</span>
<span id="cb3-807"><a href="#cb3-807" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">rmvnorm</span>(n1, mu1, Sigma1),</span>
<span id="cb3-808"><a href="#cb3-808" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">rmvnorm</span>(n2, mu2, Sigma2),</span>
<span id="cb3-809"><a href="#cb3-809" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">rmvnorm</span>(n3, mu3, Sigma3))</span>
<span id="cb3-810"><a href="#cb3-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-811"><a href="#cb3-811" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x.train[,<span class="dv">1</span>], x.train[,<span class="dv">2</span>], <span class="at">col=</span>couleur,<span class="at">xlab=</span><span class="st">"X1"</span>,<span class="at">ylab=</span><span class="st">"X2"</span>,<span class="at">pch=</span><span class="dv">8</span>,<span class="at">cex=</span><span class="fl">0.8</span>)</span>
<span id="cb3-812"><a href="#cb3-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-813"><a href="#cb3-813" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-814"><a href="#cb3-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-815"><a href="#cb3-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-818"><a href="#cb3-818" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-819"><a href="#cb3-819" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-820"><a href="#cb3-820" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-821"><a href="#cb3-821" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Second Gaussian example: prediction error rate (percentage), with 10000 training data. With 20 variables (columns 3 and 4), and with 100 additional noise variables (columns 5 and 6)"</span></span>
<span id="cb3-822"><a href="#cb3-822" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-gaussUnbNoise10</span></span>
<span id="cb3-823"><a href="#cb3-823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-824"><a href="#cb3-824" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(xtable)</span>
<span id="cb3-825"><a href="#cb3-825" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"Gaussian-Unbalanced-No-Noise/Example-Gaussian-Unbalanced-No-Noise-Res-10000.txt"</span>,<span class="at">header=</span>T)</span>
<span id="cb3-826"><a href="#cb3-826" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="dv">100</span><span class="sc">*</span>resTOT</span>
<span id="cb3-827"><a href="#cb3-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-828"><a href="#cb3-828" aria-hidden="true" tabindex="-1"></a>Identifier<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"Bayes classifier"</span>,<span class="st">"Bagged CARTs"</span>,<span class="st">"Random forest"</span>,<span class="st">"LVI-RF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>)</span>
<span id="cb3-829"><a href="#cb3-829" aria-hidden="true" tabindex="-1"></a>Characteristics<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">"Nmin=5"</span>,<span class="st">"Nmin=10"</span>,<span class="st">"Nmin=50"</span>,<span class="st">"Nmin=150"</span>,<span class="st">"Nmin=250"</span>,<span class="st">"Nmin=350"</span>,<span class="st">"k=3000,Bsel=100"</span>,<span class="st">"k=3000,Bsel=50"</span>,<span class="st">"alpha=1"</span>,<span class="st">"alpha=0.75"</span>,<span class="st">"alpha=0.5"</span>,<span class="st">"alpha=0.25"</span>, <span class="st">"k=1000"</span>,<span class="st">"k=1500"</span>,<span class="st">"k=2500"</span>)</span>
<span id="cb3-830"><a href="#cb3-830" aria-hidden="true" tabindex="-1"></a>Table<span class="ot">=</span><span class="fu">cbind</span>(Identifier,Characteristics,<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,mean),<span class="fu">paste</span>(<span class="st">"("</span>,<span class="fu">round</span>(<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,sd),<span class="dv">3</span>),<span class="st">")"</span>,<span class="at">sep=</span><span class="st">""</span>))</span>
<span id="cb3-831"><a href="#cb3-831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-832"><a href="#cb3-832" aria-hidden="true" tabindex="-1"></a>TableOrdered3<span class="ot">=</span>Table[<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,<span class="dv">5</span><span class="sc">:</span><span class="dv">10</span>,<span class="dv">17</span><span class="sc">:</span><span class="dv">19</span>,<span class="dv">4</span>,<span class="dv">11</span><span class="sc">:</span><span class="dv">16</span>),]</span>
<span id="cb3-833"><a href="#cb3-833" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(TableOrdered3)<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Method"</span>,<span class="st">"Parameters"</span>,<span class="st">"Error rate"</span>,<span class="st">"(sd)"</span>)</span>
<span id="cb3-834"><a href="#cb3-834" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(TableOrdered3)<span class="ot">=</span><span class="cn">NULL</span></span>
<span id="cb3-835"><a href="#cb3-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-836"><a href="#cb3-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-837"><a href="#cb3-837" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"Gaussian-Unbalanced-With-Noise/Example-Gaussian-Unbalanced-With-Noise-Res-10000.txt"</span>,<span class="at">header=</span>T)</span>
<span id="cb3-838"><a href="#cb3-838" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="dv">100</span><span class="sc">*</span>resTOT</span>
<span id="cb3-839"><a href="#cb3-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-840"><a href="#cb3-840" aria-hidden="true" tabindex="-1"></a>Identifier<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"Bayes classifier"</span>,<span class="st">"Bagged CARTs"</span>,<span class="st">"Random forest"</span>,<span class="st">"LVI-RF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>)</span>
<span id="cb3-841"><a href="#cb3-841" aria-hidden="true" tabindex="-1"></a>Characteristics<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">"Nmin=5"</span>,<span class="st">"Nmin=10"</span>,<span class="st">"Nmin=50"</span>,<span class="st">"Nmin=150"</span>,<span class="st">"Nmin=250"</span>,<span class="st">"Nmin=350"</span>,<span class="st">"k=3000,Bsel=100"</span>,<span class="st">"k=3000,Bsel=50"</span>,<span class="st">"alpha=1"</span>,<span class="st">"alpha=0.75"</span>,<span class="st">"alpha=0.5"</span>,<span class="st">"alpha=0.25"</span>, <span class="st">"k=1000"</span>,<span class="st">"k=1500"</span>,<span class="st">"k=2500"</span>)</span>
<span id="cb3-842"><a href="#cb3-842" aria-hidden="true" tabindex="-1"></a>Table<span class="ot">=</span><span class="fu">cbind</span>(Identifier,Characteristics,<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,mean),<span class="fu">paste</span>(<span class="st">"("</span>,<span class="fu">round</span>(<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,sd),<span class="dv">3</span>),<span class="st">")"</span>,<span class="at">sep=</span><span class="st">""</span>))</span>
<span id="cb3-843"><a href="#cb3-843" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-844"><a href="#cb3-844" aria-hidden="true" tabindex="-1"></a>TableOrdered4<span class="ot">=</span>Table[<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,<span class="dv">5</span><span class="sc">:</span><span class="dv">10</span>,<span class="dv">17</span><span class="sc">:</span><span class="dv">19</span>,<span class="dv">4</span>,<span class="dv">11</span><span class="sc">:</span><span class="dv">16</span>),]</span>
<span id="cb3-845"><a href="#cb3-845" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(TableOrdered4)<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Method"</span>,<span class="st">"Parameters"</span>,<span class="st">"Error rate"</span>,<span class="st">"(sd)"</span>)</span>
<span id="cb3-846"><a href="#cb3-846" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(TableOrdered4)<span class="ot">=</span><span class="cn">NULL</span></span>
<span id="cb3-847"><a href="#cb3-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-848"><a href="#cb3-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-849"><a href="#cb3-849" aria-hidden="true" tabindex="-1"></a>Table4<span class="ot">=</span><span class="fu">cbind</span>(TableOrdered3,TableOrdered4[,<span class="dv">3</span><span class="sc">:</span><span class="dv">4</span>])</span>
<span id="cb3-850"><a href="#cb3-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-851"><a href="#cb3-851" aria-hidden="true" tabindex="-1"></a>kableExtra<span class="sc">::</span><span class="fu">kable</span>(Table4, <span class="at">row.names=</span><span class="cn">NA</span>)</span>
<span id="cb3-852"><a href="#cb3-852" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-853"><a href="#cb3-853" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-854"><a href="#cb3-854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-855"><a href="#cb3-855" aria-hidden="true" tabindex="-1"></a>In this example, when no additional noise is considered, bagging CARTs and Random forest have similar performance, which is once again slightly beaten by a Nearest-neighbors random forest with moderate number of neighbors. When the number of noise variable increases, surprisingly bagging Carts outperforms classic random forest, and is slightly beaten by the Local variable importance RF which manages to select important variables to build trees.</span>
<span id="cb3-856"><a href="#cb3-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-857"><a href="#cb3-857" aria-hidden="true" tabindex="-1"></a>Finally, we performed an independent experiment using the same unbalanced design with noise where we also included a comparison with LazyRF and the univariate and multivariate kernel approach on only 500 test data and 4 replicates. The total experiment took 41 days to run using 10 cores of a standard high performance computing cluster.</span>
<span id="cb3-858"><a href="#cb3-858" aria-hidden="true" tabindex="-1"></a>The results are displayed in @tbl-Small. Even though it is hard to compare the results on such small experiments (500 tests hardly cover a 23-dimensional space), there is no clear performance gain for methods LazyRF, Multi-K and Uni-K, who run up to 750 thousand times slower than a classic RF.</span>
<span id="cb3-859"><a href="#cb3-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-860"><a href="#cb3-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-863"><a href="#cb3-863" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-864"><a href="#cb3-864" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-Small</span></span>
<span id="cb3-865"><a href="#cb3-865" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-866"><a href="#cb3-866" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-867"><a href="#cb3-867" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Smaller second Gaussian example: prediction error rate for only 500 test data, with runtime comparison"</span></span>
<span id="cb3-868"><a href="#cb3-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-869"><a href="#cb3-869" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(xtable)</span>
<span id="cb3-870"><a href="#cb3-870" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"Gaussian-Unbalanced-With-Noise/Unbalanced-Noise-Small.Res.txt"</span>,<span class="at">header=</span>T)</span>
<span id="cb3-871"><a href="#cb3-871" aria-hidden="true" tabindex="-1"></a>resTime<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"Gaussian-Unbalanced-With-Noise/Unbalanced-Noise-Small-time.txt"</span>,<span class="at">header=</span>T)</span>
<span id="cb3-872"><a href="#cb3-872" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="dv">100</span><span class="sc">*</span>resTOT</span>
<span id="cb3-873"><a href="#cb3-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-874"><a href="#cb3-874" aria-hidden="true" tabindex="-1"></a>Identifier<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"Bagged CARTs"</span>,<span class="st">"Random forest"</span>,<span class="st">"LVI-RF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"Multi-K"</span>, <span class="st">"Uni-K"</span>)</span>
<span id="cb3-875"><a href="#cb3-875" aria-hidden="true" tabindex="-1"></a>Characteristics<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">"Nmin=5"</span>,<span class="st">"Nmin=10"</span>,<span class="st">"Nmin=50"</span>,<span class="st">"Nmin=150"</span>,<span class="st">"Nmin=250"</span>,<span class="st">"Nmin=350"</span>,<span class="st">"k=3000,Bsel=100"</span>,<span class="st">"k=3000,Bsel=50"</span>,<span class="st">"alpha=1"</span>,<span class="st">"alpha=0.75"</span>,<span class="st">"alpha=0.5"</span>,<span class="st">"alpha=0.25"</span>, <span class="st">"k=1000"</span>,<span class="st">""</span>,<span class="st">""</span>)</span>
<span id="cb3-876"><a href="#cb3-876" aria-hidden="true" tabindex="-1"></a>Table<span class="ot">=</span><span class="fu">cbind</span>(Identifier,Characteristics,<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,mean),<span class="fu">paste</span>(<span class="st">"("</span>,<span class="fu">round</span>(<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,sd),<span class="dv">3</span>),<span class="st">")"</span>,<span class="at">sep=</span><span class="st">""</span>),<span class="fu">round</span>(<span class="fu">apply</span>(resTime,<span class="dv">2</span>,mean),<span class="dv">1</span>))</span>
<span id="cb3-877"><a href="#cb3-877" aria-hidden="true" tabindex="-1"></a>Table[<span class="fu">is.na</span>(Table[,<span class="dv">5</span>]),<span class="dv">5</span>]<span class="ot">&lt;-</span><span class="st">""</span></span>
<span id="cb3-878"><a href="#cb3-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-879"><a href="#cb3-879" aria-hidden="true" tabindex="-1"></a>TableOrderedS<span class="ot">=</span>Table[<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="dv">4</span><span class="sc">:</span><span class="dv">9</span>,<span class="dv">16</span>,<span class="dv">3</span>,<span class="dv">10</span><span class="sc">:</span><span class="dv">15</span>,<span class="dv">17</span><span class="sc">:</span><span class="dv">18</span>),]</span>
<span id="cb3-880"><a href="#cb3-880" aria-hidden="true" tabindex="-1"></a>TableOrderedS<span class="ot">=</span>TableOrderedS[<span class="sc">-</span><span class="dv">12</span>,]</span>
<span id="cb3-881"><a href="#cb3-881" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(TableOrderedS)<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Method"</span>,<span class="st">"Parameters"</span>,<span class="st">"Error rate"</span>,<span class="st">"(sd)"</span>,<span class="st">"RunTime (seconds)"</span>)</span>
<span id="cb3-882"><a href="#cb3-882" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(TableOrderedS)<span class="ot">=</span><span class="cn">NULL</span></span>
<span id="cb3-883"><a href="#cb3-883" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-884"><a href="#cb3-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-885"><a href="#cb3-885" aria-hidden="true" tabindex="-1"></a>kableExtra<span class="sc">::</span><span class="fu">kable</span>(TableOrderedS, <span class="at">row.names=</span><span class="cn">NA</span>)</span>
<span id="cb3-886"><a href="#cb3-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-887"><a href="#cb3-887" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-888"><a href="#cb3-888" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-889"><a href="#cb3-889" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-890"><a href="#cb3-890" aria-hidden="true" tabindex="-1"></a><span class="fu">## Spherical fragmented example {#sec-SphereExample}</span></span>
<span id="cb3-891"><a href="#cb3-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-892"><a href="#cb3-892" aria-hidden="true" tabindex="-1"></a>We consider an example that combines a fragmentation situation with a spherical data distribution to challenge the splitting rules of standard random forests. Datapoints are drawn from a 3-dimensional Gaussian centered distribution with variance $4$ and null covariance. The classes are drawn with uneven probabilities from three labels depending on the location.</span>
<span id="cb3-893"><a href="#cb3-893" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-894"><a href="#cb3-894" aria-hidden="true" tabindex="-1"></a>For datapoints within a 2.5 distance from the origin:</span>
<span id="cb3-895"><a href="#cb3-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-896"><a href="#cb3-896" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>if the angle with the first axis is less than 120° in the first 2 dimensions projection <span class="co">[</span><span class="ot">$(x_1,x_2)$ projection</span><span class="co">]</span>, the class is 1 with probability 0.8, and 2 and 3 with probability 0.1 ;</span>
<span id="cb3-897"><a href="#cb3-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-898"><a href="#cb3-898" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>if the angle with the first axis is greater than 240° in the first 2 dimensions projection, it is class 2 with probability 0.8 and 1 or 3 with probability 0.1 </span>
<span id="cb3-899"><a href="#cb3-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-900"><a href="#cb3-900" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>if the angle is between 120° and 240°, and class 3 with probability 0.8, and 1 or 2 with probability 0.1 otherwise.</span>
<span id="cb3-901"><a href="#cb3-901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-902"><a href="#cb3-902" aria-hidden="true" tabindex="-1"></a>If the data point is within a 2.5 to 3.75 distance to the origin, the label</span>
<span id="cb3-903"><a href="#cb3-903" aria-hidden="true" tabindex="-1"></a>class is drawn as previously but considering the $(x_1,x_3)$ projections, and</span>
<span id="cb3-904"><a href="#cb3-904" aria-hidden="true" tabindex="-1"></a>if the distance is greater than 3.75 we consider the $(x_2,x3)$ projections.</span>
<span id="cb3-905"><a href="#cb3-905" aria-hidden="true" tabindex="-1"></a>An example is illustrated in @fig-SpherFrag.</span>
<span id="cb3-906"><a href="#cb3-906" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-907"><a href="#cb3-907" aria-hidden="true" tabindex="-1"></a>In this example we performed a slightly different runtime comparison of all</span>
<span id="cb3-908"><a href="#cb3-908" aria-hidden="true" tabindex="-1"></a>methods, conducting the experiment for only one test datapoint and using only</span>
<span id="cb3-909"><a href="#cb3-909" aria-hidden="true" tabindex="-1"></a>one computing node. This allows a fairer comparison between methods which make</span>
<span id="cb3-910"><a href="#cb3-910" aria-hidden="true" tabindex="-1"></a>use of global approaches and those that are entirely local. Results are given</span>
<span id="cb3-911"><a href="#cb3-911" aria-hidden="true" tabindex="-1"></a>as fold-time the runtime of the classic RF, in @tbl-Spherical.</span>
<span id="cb3-912"><a href="#cb3-912" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-913"><a href="#cb3-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-916"><a href="#cb3-916" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-917"><a href="#cb3-917" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.height: 4</span></span>
<span id="cb3-918"><a href="#cb3-918" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig.width: 4</span></span>
<span id="cb3-919"><a href="#cb3-919" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-SpherFrag</span></span>
<span id="cb3-920"><a href="#cb3-920" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Spherical fragmented example: two first explanatory variables $X_1$ and $X_2$ ;    colors indicate the class labels (1-sky blue, 2-purple, 3-sand)."</span></span>
<span id="cb3-921"><a href="#cb3-921" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-922"><a href="#cb3-922" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-923"><a href="#cb3-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-924"><a href="#cb3-924" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb3-925"><a href="#cb3-925" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mvtnorm)</span>
<span id="cb3-926"><a href="#cb3-926" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-927"><a href="#cb3-927" aria-hidden="true" tabindex="-1"></a>num.train <span class="ot">&lt;-</span> <span class="dv">10000</span></span>
<span id="cb3-928"><a href="#cb3-928" aria-hidden="true" tabindex="-1"></a>n<span class="ot">=</span>num.train</span>
<span id="cb3-929"><a href="#cb3-929" aria-hidden="true" tabindex="-1"></a>x.train <span class="ot">&lt;-</span> <span class="fu">rmvnorm</span>(num.train,<span class="fu">rep</span>(<span class="dv">0</span>,<span class="dv">3</span>),<span class="fu">diag</span>(<span class="fu">rep</span>(<span class="dv">4</span>,<span class="dv">3</span>)))</span>
<span id="cb3-930"><a href="#cb3-930" aria-hidden="true" tabindex="-1"></a>dist.origin.train <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">apply</span>(x.train<span class="sc">^</span><span class="dv">2</span>,<span class="dv">1</span>,sum))</span>
<span id="cb3-931"><a href="#cb3-931" aria-hidden="true" tabindex="-1"></a>cosx<span class="ot">=</span>x.train[,<span class="dv">1</span>] <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="fu">apply</span>(x.train[,<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>)]<span class="sc">^</span><span class="dv">2</span>,<span class="dv">1</span>,sum))</span>
<span id="cb3-932"><a href="#cb3-932" aria-hidden="true" tabindex="-1"></a>cosy<span class="ot">=</span>x.train[,<span class="dv">2</span>] <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="fu">apply</span>(x.train[,<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)]<span class="sc">^</span><span class="dv">2</span>,<span class="dv">1</span>,sum))</span>
<span id="cb3-933"><a href="#cb3-933" aria-hidden="true" tabindex="-1"></a>cosz<span class="ot">=</span>x.train[,<span class="dv">3</span>] <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="fu">apply</span>(x.train[,<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>)]<span class="sc">^</span><span class="dv">2</span>,<span class="dv">1</span>,sum))</span>
<span id="cb3-934"><a href="#cb3-934" aria-hidden="true" tabindex="-1"></a>ind3 <span class="ot">&lt;-</span> dist.origin.train<span class="sc">&gt;</span><span class="fl">3.75</span></span>
<span id="cb3-935"><a href="#cb3-935" aria-hidden="true" tabindex="-1"></a>ind2 <span class="ot">&lt;-</span> dist.origin.train<span class="sc">&gt;</span><span class="fl">2.5</span> <span class="sc">&amp;</span> dist.origin.train<span class="sc">&lt;=</span><span class="fl">3.75</span></span>
<span id="cb3-936"><a href="#cb3-936" aria-hidden="true" tabindex="-1"></a>ind1 <span class="ot">&lt;-</span> dist.origin.train<span class="sc">&lt;=</span><span class="fl">2.5</span></span>
<span id="cb3-937"><a href="#cb3-937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-938"><a href="#cb3-938" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-939"><a href="#cb3-939" aria-hidden="true" tabindex="-1"></a>classe.train <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>,num.train)</span>
<span id="cb3-940"><a href="#cb3-940" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>num.train)</span>
<span id="cb3-941"><a href="#cb3-941" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb3-942"><a href="#cb3-942" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (ind1[i] )</span>
<span id="cb3-943"><a href="#cb3-943" aria-hidden="true" tabindex="-1"></a>  { </span>
<span id="cb3-944"><a href="#cb3-944" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x.train[i,<span class="dv">1</span>]<span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">&amp;</span> cosy[i]<span class="sc">&gt;</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>) ) </span>
<span id="cb3-945"><a href="#cb3-945" aria-hidden="true" tabindex="-1"></a>        {classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.8</span>,<span class="fl">0.1</span>,<span class="fl">0.1</span>)) } <span class="cf">else</span>     <span class="cf">if</span> (x.train[i,<span class="dv">1</span>]<span class="sc">&lt;</span><span class="dv">0</span> <span class="sc">&amp;</span> cosy[i]<span class="sc">&gt;</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>) ) </span>
<span id="cb3-946"><a href="#cb3-946" aria-hidden="true" tabindex="-1"></a>        {classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.8</span>,<span class="fl">0.1</span>)) } <span class="cf">else</span>  classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.1</span>,<span class="fl">0.8</span>))</span>
<span id="cb3-947"><a href="#cb3-947" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb3-948"><a href="#cb3-948" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (ind2[i]) </span>
<span id="cb3-949"><a href="#cb3-949" aria-hidden="true" tabindex="-1"></a>  { </span>
<span id="cb3-950"><a href="#cb3-950" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x.train[i,<span class="dv">2</span>]<span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">&amp;</span> cosz[i]<span class="sc">&gt;</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>) ) </span>
<span id="cb3-951"><a href="#cb3-951" aria-hidden="true" tabindex="-1"></a>        {classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.8</span>,<span class="fl">0.1</span>,<span class="fl">0.1</span>)) } <span class="cf">else</span>     <span class="cf">if</span> (x.train[i,<span class="dv">2</span>]<span class="sc">&lt;</span><span class="dv">0</span> <span class="sc">&amp;</span> cosz[i]<span class="sc">&gt;</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>) ) </span>
<span id="cb3-952"><a href="#cb3-952" aria-hidden="true" tabindex="-1"></a>        {classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.8</span>,<span class="fl">0.1</span>)) } <span class="cf">else</span>  classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.1</span>,<span class="fl">0.8</span>))</span>
<span id="cb3-953"><a href="#cb3-953" aria-hidden="true" tabindex="-1"></a>  }  </span>
<span id="cb3-954"><a href="#cb3-954" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (ind3[i]) </span>
<span id="cb3-955"><a href="#cb3-955" aria-hidden="true" tabindex="-1"></a>    { </span>
<span id="cb3-956"><a href="#cb3-956" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x.train[i,<span class="dv">3</span>]<span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">&amp;</span> cosx[i]<span class="sc">&gt;</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>) ) </span>
<span id="cb3-957"><a href="#cb3-957" aria-hidden="true" tabindex="-1"></a>        {classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.8</span>,<span class="fl">0.1</span>,<span class="fl">0.1</span>)) } <span class="cf">else</span>     <span class="cf">if</span> (x.train[i,<span class="dv">3</span>]<span class="sc">&lt;</span><span class="dv">0</span> <span class="sc">&amp;</span> cosx[i]<span class="sc">&gt;</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>) ) </span>
<span id="cb3-958"><a href="#cb3-958" aria-hidden="true" tabindex="-1"></a>        {classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.8</span>,<span class="fl">0.1</span>)) } <span class="cf">else</span>  classe.train[i] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="dv">1</span>, <span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.1</span>,<span class="fl">0.8</span>))</span>
<span id="cb3-959"><a href="#cb3-959" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb3-960"><a href="#cb3-960" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-961"><a href="#cb3-961" aria-hidden="true" tabindex="-1"></a>couleur <span class="ot">&lt;-</span> <span class="fu">rep</span>(safe_colorblind_palette[<span class="dv">1</span>], n)</span>
<span id="cb3-962"><a href="#cb3-962" aria-hidden="true" tabindex="-1"></a>couleur[classe.train<span class="sc">==</span><span class="dv">1</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">1</span>]</span>
<span id="cb3-963"><a href="#cb3-963" aria-hidden="true" tabindex="-1"></a>couleur[classe.train<span class="sc">==</span><span class="dv">2</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">2</span>]</span>
<span id="cb3-964"><a href="#cb3-964" aria-hidden="true" tabindex="-1"></a>couleur[classe.train<span class="sc">==</span><span class="dv">3</span>] <span class="ot">&lt;-</span> safe_colorblind_palette[<span class="dv">3</span>]</span>
<span id="cb3-965"><a href="#cb3-965" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph generation</span></span>
<span id="cb3-966"><a href="#cb3-966" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x.train[,<span class="dv">1</span>], x.train[,<span class="dv">2</span>], <span class="at">col=</span>couleur,<span class="at">xlab=</span><span class="st">"X1"</span>,<span class="at">ylab=</span><span class="st">"X2"</span>,<span class="at">pch=</span><span class="dv">8</span>,<span class="at">cex=</span><span class="fl">0.8</span>)</span>
<span id="cb3-967"><a href="#cb3-967" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-968"><a href="#cb3-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-969"><a href="#cb3-969" aria-hidden="true" tabindex="-1"></a>In this example, once again bagging CARTs outperforms all other methods, while classic random forests are beaten by almost all other methods except nearest-neighbour Random Forests, who suffer most from the fragmentation issue. Local variable importance RF and Case-specific Random forests perform quite well. </span>
<span id="cb3-970"><a href="#cb3-970" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-971"><a href="#cb3-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-974"><a href="#cb3-974" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-975"><a href="#cb3-975" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-Spherical</span></span>
<span id="cb3-976"><a href="#cb3-976" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-977"><a href="#cb3-977" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-978"><a href="#cb3-978" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Spherical fragmented example: prediction error rate (percentage), with 10000 training data, and runtime comparison"</span></span>
<span id="cb3-979"><a href="#cb3-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-980"><a href="#cb3-980" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(xtable)</span>
<span id="cb3-981"><a href="#cb3-981" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"Spherical/Spherical.txt"</span>,<span class="at">header=</span>T)</span>
<span id="cb3-982"><a href="#cb3-982" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="dv">100</span><span class="sc">*</span>resTOT</span>
<span id="cb3-983"><a href="#cb3-983" aria-hidden="true" tabindex="-1"></a>resTime<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"Spherical/Spherical-Time.txt"</span>,<span class="at">header=</span>T)</span>
<span id="cb3-984"><a href="#cb3-984" aria-hidden="true" tabindex="-1"></a>resTime<span class="ot">&lt;-</span>resTime[<span class="dv">1</span>,]</span>
<span id="cb3-985"><a href="#cb3-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-986"><a href="#cb3-986" aria-hidden="true" tabindex="-1"></a>Identifier<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"Bagged CARTs"</span>,<span class="st">"Random forest"</span>,<span class="st">"LVI-RF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>, <span class="st">"DVSRF"</span>,<span class="st">"DVSRF"</span>, <span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>, <span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>)</span>
<span id="cb3-987"><a href="#cb3-987" aria-hidden="true" tabindex="-1"></a>Characteristics<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">"Nmin=5"</span>,<span class="st">"Nmin=10"</span>,<span class="st">"Nmin=50"</span>,<span class="st">"Nmin=150"</span>,<span class="st">"Nmin=250"</span>,<span class="st">"Nmin=350"</span>,<span class="st">"k=3000,Bsel=100"</span>,<span class="st">"k=3000,Bsel=50"</span>,<span class="st">"alpha=1"</span>,<span class="st">"alpha=0.75"</span>,<span class="st">"alpha=0.5"</span>,<span class="st">"alpha=0.25"</span>, <span class="st">"k=1000"</span>,<span class="st">"k=1500"</span>,<span class="st">"k=2500"</span>)</span>
<span id="cb3-988"><a href="#cb3-988" aria-hidden="true" tabindex="-1"></a>Table<span class="ot">=</span><span class="fu">cbind</span>(Identifier,Characteristics,<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,mean,<span class="at">na.rm=</span><span class="cn">TRUE</span>),<span class="fu">paste</span>(<span class="st">"("</span>,<span class="fu">round</span>(<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,sd,<span class="at">na.rm=</span><span class="cn">TRUE</span>),<span class="dv">3</span>),<span class="st">")"</span>,<span class="at">sep=</span><span class="st">""</span>),<span class="fu">round</span>(<span class="fu">t</span>(resTime[<span class="dv">1</span>,]<span class="sc">/</span>resTime[,<span class="dv">2</span>]),<span class="dv">2</span>))</span>
<span id="cb3-989"><a href="#cb3-989" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-990"><a href="#cb3-990" aria-hidden="true" tabindex="-1"></a>TableOrdered5<span class="ot">=</span>Table[<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="dv">4</span><span class="sc">:</span><span class="dv">9</span>,<span class="dv">16</span><span class="sc">:</span><span class="dv">18</span>,<span class="dv">3</span>,<span class="dv">10</span><span class="sc">:</span><span class="dv">15</span>),]</span>
<span id="cb3-991"><a href="#cb3-991" aria-hidden="true" tabindex="-1"></a><span class="co">#TableOrdered5=Table</span></span>
<span id="cb3-992"><a href="#cb3-992" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(TableOrdered5)<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Method"</span>,<span class="st">"Parameters"</span>,<span class="st">"Error rate"</span>,<span class="st">"(sd)"</span>, <span class="st">"Runtime (fold RF)"</span>)</span>
<span id="cb3-993"><a href="#cb3-993" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(TableOrdered5)<span class="ot">=</span><span class="cn">NULL</span></span>
<span id="cb3-994"><a href="#cb3-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-995"><a href="#cb3-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-996"><a href="#cb3-996" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-997"><a href="#cb3-997" aria-hidden="true" tabindex="-1"></a>Table5<span class="ot">=</span><span class="fu">cbind</span>(TableOrdered5)</span>
<span id="cb3-998"><a href="#cb3-998" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-999"><a href="#cb3-999" aria-hidden="true" tabindex="-1"></a>kableExtra<span class="sc">::</span><span class="fu">kable</span>(Table5, <span class="at">row.names=</span><span class="cn">NA</span>)</span>
<span id="cb3-1000"><a href="#cb3-1000" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1001"><a href="#cb3-1001" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1002"><a href="#cb3-1002" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1003"><a href="#cb3-1003" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1004"><a href="#cb3-1004" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1005"><a href="#cb3-1005" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1006"><a href="#cb3-1006" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population genetics example {#sec-geneticsExample}</span></span>
<span id="cb3-1007"><a href="#cb3-1007" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1008"><a href="#cb3-1008" aria-hidden="true" tabindex="-1"></a>We now compare a set of local strategies on a basic population genetics example</span>
<span id="cb3-1009"><a href="#cb3-1009" aria-hidden="true" tabindex="-1"></a>introduced in @pudlo:etal:2016. The historical link between three populations of a given species is of interest. More precisely, we are interested in studying whether a third population emerged from a first or a second population, or whether it emerged from a mixture between the first two. This problem is hence a three classes classification question. The data is made of $1,000$ autosomal single-nucleotide polymorphisms (SNPs). </span>
<span id="cb3-1010"><a href="#cb3-1010" aria-hidden="true" tabindex="-1"></a>We assume that the distances between these loci on the genome are large enough to neglect linkage disequilibrium, we hence consider them as having independent ancestral genealogies.</span>
<span id="cb3-1011"><a href="#cb3-1011" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1012"><a href="#cb3-1012" aria-hidden="true" tabindex="-1"></a>The data is summarized thanks to $d=48$ summary statistics available within the DIY<span class="sc">\-</span>ABC software for SNP markers <span class="co">[</span><span class="ot">@cornuet:etal:2014</span><span class="co">]</span>, which is also used to simulate training and test sets </span>
<span id="cb3-1013"><a href="#cb3-1013" aria-hidden="true" tabindex="-1"></a>respectively of size $10,000$ and $1,000$, equally distributed among the three scenarios.</span>
<span id="cb3-1014"><a href="#cb3-1014" aria-hidden="true" tabindex="-1"></a>Moreover, the data are constrained to be drawn in the $<span class="co">[</span><span class="ot">-1;1</span><span class="co">]</span>^2$ square on the</span>
<span id="cb3-1015"><a href="#cb3-1015" aria-hidden="true" tabindex="-1"></a>linear discriminant analysis (LDA) axes projections graph, which is a region</span>
<span id="cb3-1016"><a href="#cb3-1016" aria-hidden="true" tabindex="-1"></a>where scenarios are hard to discriminate, see @fig-popGen-LDA.</span>
<span id="cb3-1017"><a href="#cb3-1017" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1018"><a href="#cb3-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1021"><a href="#cb3-1021" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-1022"><a href="#cb3-1022" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-popGen-LDA</span></span>
<span id="cb3-1023"><a href="#cb3-1023" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Population genetics example: projections on the LDA axes of the $10,000$ training instances ;     colors represent scenario indices: sky-blue for model 1, sand for model 2 and purple for model 3 ;    the hard to discriminate $[-1;1]^2$ region is represented by black dashed lines."</span></span>
<span id="cb3-1024"><a href="#cb3-1024" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-1025"><a href="#cb3-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1026"><a href="#cb3-1026" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">"Fig4.png"</span>,<span class="at">dpi=</span><span class="cn">NA</span>)</span>
<span id="cb3-1027"><a href="#cb3-1027" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1028"><a href="#cb3-1028" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1029"><a href="#cb3-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1030"><a href="#cb3-1030" aria-hidden="true" tabindex="-1"></a>Similarly to the Gaussian mixture examples, the methods are run ten times on</span>
<span id="cb3-1031"><a href="#cb3-1031" aria-hidden="true" tabindex="-1"></a>the same data. The averaged misclassification error rates and the associated</span>
<span id="cb3-1032"><a href="#cb3-1032" aria-hidden="true" tabindex="-1"></a>standard deviation are displayed in @tbl-GenPopResults.</span>
<span id="cb3-1033"><a href="#cb3-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1034"><a href="#cb3-1034" aria-hidden="true" tabindex="-1"></a>In this example again, bagging CARTs outperforms a classic random forest. Most local approaches can be tuned to reach a classic RF performance, but none manage to significantly outperform it, let alone reach bagging CARTs results.</span>
<span id="cb3-1035"><a href="#cb3-1035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1036"><a href="#cb3-1036" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1039"><a href="#cb3-1039" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-1040"><a href="#cb3-1040" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-GenPopResults</span></span>
<span id="cb3-1041"><a href="#cb3-1041" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb3-1042"><a href="#cb3-1042" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-1043"><a href="#cb3-1043" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Population Genetics example: prediction error rate (percentage), with 10000 training data and 1000 test data"</span></span>
<span id="cb3-1044"><a href="#cb3-1044" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1045"><a href="#cb3-1045" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(xtable)</span>
<span id="cb3-1046"><a href="#cb3-1046" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="st">"Population-Genetics/Example-Population-Genetics-Res.txt"</span>,<span class="at">header=</span>T)</span>
<span id="cb3-1047"><a href="#cb3-1047" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="dv">100</span><span class="sc">*</span>resTOT</span>
<span id="cb3-1048"><a href="#cb3-1048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1049"><a href="#cb3-1049" aria-hidden="true" tabindex="-1"></a>Identifier<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"Bagged CARTs"</span>,<span class="st">"Random forest"</span>,<span class="st">"LVI-RF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>,<span class="st">"NN-RF"</span>)</span>
<span id="cb3-1050"><a href="#cb3-1050" aria-hidden="true" tabindex="-1"></a>Characteristics<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">"Nmin=50"</span>,<span class="st">"Nmin=150"</span>,<span class="st">"Nmin=250"</span>,<span class="st">"k=3000,Bsel=100"</span>,<span class="st">"k=3000,Bsel=50"</span>,<span class="st">"alpha=1"</span>,<span class="st">"alpha=0.75"</span>,<span class="st">"alpha=0.5"</span>,<span class="st">"alpha=0.25"</span>, <span class="st">"k=1000"</span>,<span class="st">"k=1500"</span>,<span class="st">"k=2500"</span>)</span>
<span id="cb3-1051"><a href="#cb3-1051" aria-hidden="true" tabindex="-1"></a>Table<span class="ot">=</span><span class="fu">cbind</span>(Identifier,Characteristics,<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,mean),<span class="fu">paste</span>(<span class="st">"("</span>,<span class="fu">round</span>(<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,sd),<span class="dv">3</span>),<span class="st">")"</span>,<span class="at">sep=</span><span class="st">""</span>))</span>
<span id="cb3-1052"><a href="#cb3-1052" aria-hidden="true" tabindex="-1"></a>TableOrdered<span class="ot">=</span>Table[<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="dv">5</span><span class="sc">:</span><span class="dv">7</span>,<span class="dv">13</span><span class="sc">:</span><span class="dv">15</span>,<span class="dv">3</span>,<span class="dv">8</span><span class="sc">:</span><span class="dv">12</span>),]</span>
<span id="cb3-1053"><a href="#cb3-1053" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(TableOrdered)<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Method"</span>,<span class="st">"Parameters"</span>,<span class="st">"Error rate"</span>,<span class="st">"(sd)"</span>)</span>
<span id="cb3-1054"><a href="#cb3-1054" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(TableOrdered)<span class="ot">=</span><span class="cn">NULL</span></span>
<span id="cb3-1055"><a href="#cb3-1055" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1056"><a href="#cb3-1056" aria-hidden="true" tabindex="-1"></a>kableExtra<span class="sc">::</span><span class="fu">kable</span>(TableOrdered, <span class="at">row.names=</span><span class="cn">NA</span>)</span>
<span id="cb3-1057"><a href="#cb3-1057" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1058"><a href="#cb3-1058" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1059"><a href="#cb3-1059" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1060"><a href="#cb3-1060" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1061"><a href="#cb3-1061" aria-hidden="true" tabindex="-1"></a><span class="fu"># Data accessibility and reproducibility {#sec-reproducibility}</span></span>
<span id="cb3-1062"><a href="#cb3-1062" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1063"><a href="#cb3-1063" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1064"><a href="#cb3-1064" aria-hidden="true" tabindex="-1"></a>The global computational time for the examples presented above represent</span>
<span id="cb3-1065"><a href="#cb3-1065" aria-hidden="true" tabindex="-1"></a>several days of multiple cores usage and are therefore not directly proposed</span>
<span id="cb3-1066"><a href="#cb3-1066" aria-hidden="true" tabindex="-1"></a>to the reader. All codes, data and session information are available at</span>
<span id="cb3-1067"><a href="#cb3-1067" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">github.com/computorg/published-202312-cleynen-local</span><span class="co">](https://github.com/computorg/published-202312-cleynen-local)</span>.</span>
<span id="cb3-1068"><a href="#cb3-1068" aria-hidden="true" tabindex="-1"></a>Note that during the preparation of the manuscript we detect an</span>
<span id="cb3-1069"><a href="#cb3-1069" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">issue</span><span class="co">](https://github.com/imbs-hl/ranger/issues/615)</span> in the implementation of</span>
<span id="cb3-1070"><a href="#cb3-1070" aria-hidden="true" tabindex="-1"></a>the Case Specific Random Forests function (csrf) function of the R package</span>
<span id="cb3-1071"><a href="#cb3-1071" aria-hidden="true" tabindex="-1"></a>ranger and have to redo quite a lot of calculation to ensure reproducibility. </span>
<span id="cb3-1072"><a href="#cb3-1072" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1073"><a href="#cb3-1073" aria-hidden="true" tabindex="-1"></a>In this section, we reproduce the first Gaussian example presented above</span>
<span id="cb3-1074"><a href="#cb3-1074" aria-hidden="true" tabindex="-1"></a>(without additional noise) with only 500 training data, 100 test data and 5</span>
<span id="cb3-1075"><a href="#cb3-1075" aria-hidden="true" tabindex="-1"></a>replicates, to illustrate the methods and produce similar tables to</span>
<span id="cb3-1076"><a href="#cb3-1076" aria-hidden="true" tabindex="-1"></a>@tbl-gaussEqNoise10 to @tbl-GenPopResults.</span>
<span id="cb3-1077"><a href="#cb3-1077" aria-hidden="true" tabindex="-1"></a>The results in themselves are not interpretable due to the low dimensionality of the test and training data, so most methods were only illustrated with one set of parameters. However, changing parameters value in the code is straightforward.</span>
<span id="cb3-1078"><a href="#cb3-1078" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1081"><a href="#cb3-1081" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-1082"><a href="#cb3-1082" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-ToyEx</span></span>
<span id="cb3-1083"><a href="#cb3-1083" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-1084"><a href="#cb3-1084" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Toy example: prediction error rate (percentage)"</span></span>
<span id="cb3-1085"><a href="#cb3-1085" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1086"><a href="#cb3-1086" aria-hidden="true" tabindex="-1"></a><span class="do">######## Toy example : Small balanced Gaussian example without Noise  ########</span></span>
<span id="cb3-1087"><a href="#cb3-1087" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1088"><a href="#cb3-1088" aria-hidden="true" tabindex="-1"></a><span class="do">#### Required packages</span></span>
<span id="cb3-1089"><a href="#cb3-1089" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"xtable"</span>)</span>
<span id="cb3-1090"><a href="#cb3-1090" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mvtnorm)</span>
<span id="cb3-1091"><a href="#cb3-1091" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ranger)</span>
<span id="cb3-1092"><a href="#cb3-1092" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(parallel)</span>
<span id="cb3-1093"><a href="#cb3-1093" aria-hidden="true" tabindex="-1"></a>ncores <span class="ot">&lt;-</span> <span class="fu">detectCores</span>()</span>
<span id="cb3-1094"><a href="#cb3-1094" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1095"><a href="#cb3-1095" aria-hidden="true" tabindex="-1"></a><span class="do">#### Set the seed of R's random number generator</span></span>
<span id="cb3-1096"><a href="#cb3-1096" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1097"><a href="#cb3-1097" aria-hidden="true" tabindex="-1"></a>nReplicate <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb3-1098"><a href="#cb3-1098" aria-hidden="true" tabindex="-1"></a>resBayes <span class="ot">&lt;-</span> resBagging <span class="ot">&lt;-</span> resRF <span class="ot">&lt;-</span> resLVIRF <span class="ot">&lt;-</span> resCsrf5 <span class="ot">&lt;-</span> resCsrf10 <span class="ot">&lt;-</span> resDVSRF1 <span class="ot">&lt;-</span> resKVRF1 <span class="ot">&lt;-</span> resNNRF1 <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>,nReplicate)</span>
<span id="cb3-1099"><a href="#cb3-1099" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1100"><a href="#cb3-1100" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nReplicate)  {</span>
<span id="cb3-1101"><a href="#cb3-1101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1102"><a href="#cb3-1102" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1974</span><span class="sc">+</span>k)</span>
<span id="cb3-1103"><a href="#cb3-1103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1104"><a href="#cb3-1104" aria-hidden="true" tabindex="-1"></a><span class="do">### Training data generation</span></span>
<span id="cb3-1105"><a href="#cb3-1105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1106"><a href="#cb3-1106" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">500</span></span>
<span id="cb3-1107"><a href="#cb3-1107" aria-hidden="true" tabindex="-1"></a>pi0 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-1108"><a href="#cb3-1108" aria-hidden="true" tabindex="-1"></a>pi1 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-1109"><a href="#cb3-1109" aria-hidden="true" tabindex="-1"></a>pi2 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-1110"><a href="#cb3-1110" aria-hidden="true" tabindex="-1"></a>pi3 <span class="ot">&lt;-</span> <span class="fl">0.25</span></span>
<span id="cb3-1111"><a href="#cb3-1111" aria-hidden="true" tabindex="-1"></a>l <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb3-1112"><a href="#cb3-1112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1113"><a href="#cb3-1113" aria-hidden="true" tabindex="-1"></a>mu0 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="fl">0.8</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="fl">2.5</span>), l<span class="sc">/</span><span class="dv">2-1</span>))</span>
<span id="cb3-1114"><a href="#cb3-1114" aria-hidden="true" tabindex="-1"></a>Sigma0 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) )</span>
<span id="cb3-1115"><a href="#cb3-1115" aria-hidden="true" tabindex="-1"></a>mu1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="fl">3.2</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fl">2.5</span>,<span class="fl">2.5</span>), l<span class="sc">/</span><span class="dv">2-1</span>))</span>
<span id="cb3-1116"><a href="#cb3-1116" aria-hidden="true" tabindex="-1"></a>Sigma1 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>),l<span class="sc">/</span><span class="dv">2-1</span>)) )</span>
<span id="cb3-1117"><a href="#cb3-1117" aria-hidden="true" tabindex="-1"></a>mu2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="fl">2.3</span>),l<span class="sc">/</span><span class="dv">2-1</span>))</span>
<span id="cb3-1118"><a href="#cb3-1118" aria-hidden="true" tabindex="-1"></a>Sigma2 <span class="ot">&lt;-</span> <span class="fu">diag</span>( (<span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2</span>) ) )</span>
<span id="cb3-1119"><a href="#cb3-1119" aria-hidden="true" tabindex="-1"></a>mu3 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">0</span>), <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="fl">1.8</span>),l<span class="sc">/</span><span class="dv">2-1</span>))</span>
<span id="cb3-1120"><a href="#cb3-1120" aria-hidden="true" tabindex="-1"></a>Sigma3 <span class="ot">&lt;-</span> <span class="fu">diag</span>( (<span class="fu">rep</span>(<span class="fu">c</span>(<span class="fl">2.5</span>,<span class="dv">1</span>),l<span class="sc">/</span><span class="dv">2</span>) ) )</span>
<span id="cb3-1121"><a href="#cb3-1121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1122"><a href="#cb3-1122" aria-hidden="true" tabindex="-1"></a>classe <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(pi0,pi1,pi2,pi3))</span>
<span id="cb3-1123"><a href="#cb3-1123" aria-hidden="true" tabindex="-1"></a>classe <span class="ot">&lt;-</span> <span class="fu">sort</span>(classe)</span>
<span id="cb3-1124"><a href="#cb3-1124" aria-hidden="true" tabindex="-1"></a>n0 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">0</span>)</span>
<span id="cb3-1125"><a href="#cb3-1125" aria-hidden="true" tabindex="-1"></a>n1 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">1</span>)</span>
<span id="cb3-1126"><a href="#cb3-1126" aria-hidden="true" tabindex="-1"></a>n2 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">2</span>)</span>
<span id="cb3-1127"><a href="#cb3-1127" aria-hidden="true" tabindex="-1"></a>n3 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classe<span class="sc">==</span><span class="dv">3</span>)</span>
<span id="cb3-1128"><a href="#cb3-1128" aria-hidden="true" tabindex="-1"></a>x.train <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">rmvnorm</span>(n0, mu0, Sigma0), <span class="fu">rmvnorm</span>(n1, mu1, Sigma1), <span class="fu">rmvnorm</span>(n2, mu2, Sigma2), <span class="fu">rmvnorm</span>(n3, mu3, Sigma3))</span>
<span id="cb3-1129"><a href="#cb3-1129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1130"><a href="#cb3-1130" aria-hidden="true" tabindex="-1"></a><span class="do">### Test data generation</span></span>
<span id="cb3-1131"><a href="#cb3-1131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1132"><a href="#cb3-1132" aria-hidden="true" tabindex="-1"></a>nTest <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb3-1133"><a href="#cb3-1133" aria-hidden="true" tabindex="-1"></a>classeTest <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="at">size=</span>nTest, <span class="at">prob=</span><span class="fu">c</span>(pi0,pi1,pi2,pi3), <span class="at">replace=</span><span class="cn">TRUE</span>)</span>
<span id="cb3-1134"><a href="#cb3-1134" aria-hidden="true" tabindex="-1"></a>classeTest <span class="ot">&lt;-</span> <span class="fu">sort</span>(classeTest)</span>
<span id="cb3-1135"><a href="#cb3-1135" aria-hidden="true" tabindex="-1"></a>nTest0 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classeTest<span class="sc">==</span><span class="dv">0</span>)</span>
<span id="cb3-1136"><a href="#cb3-1136" aria-hidden="true" tabindex="-1"></a>nTest1 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classeTest<span class="sc">==</span><span class="dv">1</span>)</span>
<span id="cb3-1137"><a href="#cb3-1137" aria-hidden="true" tabindex="-1"></a>nTest2 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classeTest<span class="sc">==</span><span class="dv">2</span>)</span>
<span id="cb3-1138"><a href="#cb3-1138" aria-hidden="true" tabindex="-1"></a>nTest3 <span class="ot">&lt;-</span> <span class="fu">sum</span>(classeTest<span class="sc">==</span><span class="dv">3</span>)</span>
<span id="cb3-1139"><a href="#cb3-1139" aria-hidden="true" tabindex="-1"></a>x.test <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">rmvnorm</span>(nTest0, mu0, Sigma0),</span>
<span id="cb3-1140"><a href="#cb3-1140" aria-hidden="true" tabindex="-1"></a>                <span class="fu">rmvnorm</span>(nTest1, mu1, Sigma1),</span>
<span id="cb3-1141"><a href="#cb3-1141" aria-hidden="true" tabindex="-1"></a>                <span class="fu">rmvnorm</span>(nTest2, mu2, Sigma2),</span>
<span id="cb3-1142"><a href="#cb3-1142" aria-hidden="true" tabindex="-1"></a>                <span class="fu">rmvnorm</span>(nTest3, mu3, Sigma3))</span>
<span id="cb3-1143"><a href="#cb3-1143" aria-hidden="true" tabindex="-1"></a>data.train <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">mod =</span> <span class="fu">as.factor</span>(classe), x.train)</span>
<span id="cb3-1144"><a href="#cb3-1144" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(x.test) <span class="ot">&lt;-</span> <span class="fu">colnames</span>(data.train)[<span class="sc">-</span><span class="dv">1</span>]</span>
<span id="cb3-1145"><a href="#cb3-1145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1146"><a href="#cb3-1146" aria-hidden="true" tabindex="-1"></a><span class="do">#### Bayes classifier</span></span>
<span id="cb3-1147"><a href="#cb3-1147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1148"><a href="#cb3-1148" aria-hidden="true" tabindex="-1"></a>BayesClassifieur <span class="ot">&lt;-</span> <span class="cf">function</span>(x){</span>
<span id="cb3-1149"><a href="#cb3-1149" aria-hidden="true" tabindex="-1"></a>  c0 <span class="ot">&lt;-</span> pi0<span class="sc">*</span><span class="fu">dmvnorm</span>(x,<span class="at">mean=</span>mu0,<span class="at">sigma=</span>Sigma0)</span>
<span id="cb3-1150"><a href="#cb3-1150" aria-hidden="true" tabindex="-1"></a>  c1 <span class="ot">&lt;-</span> pi1<span class="sc">*</span><span class="fu">dmvnorm</span>(x,<span class="at">mean=</span>mu1,<span class="at">sigma=</span>Sigma1)</span>
<span id="cb3-1151"><a href="#cb3-1151" aria-hidden="true" tabindex="-1"></a>  c2 <span class="ot">&lt;-</span> pi2<span class="sc">*</span><span class="fu">dmvnorm</span>(x,<span class="at">mean=</span>mu2,<span class="at">sigma=</span>Sigma2)</span>
<span id="cb3-1152"><a href="#cb3-1152" aria-hidden="true" tabindex="-1"></a>  c3 <span class="ot">&lt;-</span> pi3<span class="sc">*</span><span class="fu">dmvnorm</span>(x,<span class="at">mean=</span>mu3,<span class="at">sigma=</span>Sigma3)</span>
<span id="cb3-1153"><a href="#cb3-1153" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)[<span class="fu">which.max</span>(<span class="fu">c</span>(c0,c1,c2,c3))])</span>
<span id="cb3-1154"><a href="#cb3-1154" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-1155"><a href="#cb3-1155" aria-hidden="true" tabindex="-1"></a>predBayes <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, nTest)</span>
<span id="cb3-1156"><a href="#cb3-1156" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nTest) predBayes[i] <span class="ot">&lt;-</span> <span class="fu">BayesClassifieur</span>(x.test[i,])</span>
<span id="cb3-1157"><a href="#cb3-1157" aria-hidden="true" tabindex="-1"></a>resBayes[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predBayes <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1158"><a href="#cb3-1158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1159"><a href="#cb3-1159" aria-hidden="true" tabindex="-1"></a><span class="do">### Bagging</span></span>
<span id="cb3-1160"><a href="#cb3-1160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1161"><a href="#cb3-1161" aria-hidden="true" tabindex="-1"></a>baggedRf <span class="ot">&lt;-</span> <span class="fu">ranger</span>(<span class="at">formula =</span> mod<span class="sc">~</span>., <span class="at">data =</span> data.train, <span class="at">num.trees =</span> <span class="dv">100</span>, </span>
<span id="cb3-1162"><a href="#cb3-1162" aria-hidden="true" tabindex="-1"></a>                   <span class="at">mtry =</span> <span class="fu">dim</span>(x.train)[<span class="dv">2</span>], <span class="at">num.threads =</span> ncores)</span>
<span id="cb3-1163"><a href="#cb3-1163" aria-hidden="true" tabindex="-1"></a>predBagging <span class="ot">&lt;-</span> <span class="fu">predict</span>(<span class="at">object =</span> baggedRf, <span class="at">data =</span> x.test, <span class="at">num.threads =</span> ncores)</span>
<span id="cb3-1164"><a href="#cb3-1164" aria-hidden="true" tabindex="-1"></a>resBagging[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predBagging<span class="sc">$</span>predictions <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1165"><a href="#cb3-1165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1166"><a href="#cb3-1166" aria-hidden="true" tabindex="-1"></a><span class="do">#### Random Forests</span></span>
<span id="cb3-1167"><a href="#cb3-1167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1168"><a href="#cb3-1168" aria-hidden="true" tabindex="-1"></a>classicRF <span class="ot">&lt;-</span> <span class="fu">ranger</span>(<span class="at">formula =</span> mod<span class="sc">~</span>., <span class="at">data =</span> data.train,</span>
<span id="cb3-1169"><a href="#cb3-1169" aria-hidden="true" tabindex="-1"></a>                    <span class="at">num.trees =</span> <span class="dv">100</span>, <span class="at">num.threads =</span> ncores)</span>
<span id="cb3-1170"><a href="#cb3-1170" aria-hidden="true" tabindex="-1"></a>predRF <span class="ot">&lt;-</span> <span class="fu">predict</span>(<span class="at">object =</span> classicRF, <span class="at">data =</span> x.test, <span class="at">num.threads =</span> ncores)</span>
<span id="cb3-1171"><a href="#cb3-1171" aria-hidden="true" tabindex="-1"></a>resRF[k] <span class="ot">&lt;-</span><span class="fu">mean</span>(predRF<span class="sc">$</span>predictions <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1172"><a href="#cb3-1172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1173"><a href="#cb3-1173" aria-hidden="true" tabindex="-1"></a><span class="do">#### Local variable importance RF</span></span>
<span id="cb3-1174"><a href="#cb3-1174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1175"><a href="#cb3-1175" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"LocalVarImpRF.R"</span>)</span>
<span id="cb3-1176"><a href="#cb3-1176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1177"><a href="#cb3-1177" aria-hidden="true" tabindex="-1"></a>rf.ranger <span class="ot">&lt;-</span> <span class="fu">ranger</span>(mod <span class="sc">~</span> ., <span class="at">data =</span> data.train, <span class="at">num.trees =</span> <span class="dv">100</span>, <span class="at">num.threads =</span> ncores)</span>
<span id="cb3-1178"><a href="#cb3-1178" aria-hidden="true" tabindex="-1"></a>impxStd <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> nTest, <span class="at">ncol=</span><span class="fu">dim</span>(x.train)[<span class="dv">2</span>])</span>
<span id="cb3-1179"><a href="#cb3-1179" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nTest) </span>
<span id="cb3-1180"><a href="#cb3-1180" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb3-1181"><a href="#cb3-1181" aria-hidden="true" tabindex="-1"></a>  impxStd[i,] <span class="ot">&lt;-</span> <span class="fu">LocalVarImp</span>(rf.ranger, x.test[i,,<span class="at">drop=</span><span class="cn">FALSE</span>])</span>
<span id="cb3-1182"><a href="#cb3-1182" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-1183"><a href="#cb3-1183" aria-hidden="true" tabindex="-1"></a>predLVIRF <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">c</span>(),<span class="at">levels=</span><span class="fu">levels</span>(data.train<span class="sc">$</span>mod))</span>
<span id="cb3-1184"><a href="#cb3-1184" aria-hidden="true" tabindex="-1"></a><span class="co"># tp &lt;- txtProgressBar(min = 1, max = nTest, style = 3, char = "*")</span></span>
<span id="cb3-1185"><a href="#cb3-1185" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nTest)</span>
<span id="cb3-1186"><a href="#cb3-1186" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb3-1187"><a href="#cb3-1187" aria-hidden="true" tabindex="-1"></a>  rf.local.ranger <span class="ot">&lt;-</span> <span class="fu">ranger</span>(mod <span class="sc">~</span> ., <span class="at">data =</span> data.train, <span class="at">num.trees =</span> <span class="dv">100</span>, </span>
<span id="cb3-1188"><a href="#cb3-1188" aria-hidden="true" tabindex="-1"></a>                            <span class="at">split.select.weights =</span> impxStd[i,], <span class="at">num.threads =</span> ncores)</span>
<span id="cb3-1189"><a href="#cb3-1189" aria-hidden="true" tabindex="-1"></a>  predLVIRF[i] <span class="ot">&lt;-</span> <span class="fu">predict</span>(rf.local.ranger, <span class="at">data=</span>x.test[i,,<span class="at">drop=</span><span class="cn">FALSE</span>])<span class="sc">$</span>predictions</span>
<span id="cb3-1190"><a href="#cb3-1190" aria-hidden="true" tabindex="-1"></a><span class="co">#  setTxtProgressBar(tp, i)</span></span>
<span id="cb3-1191"><a href="#cb3-1191" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-1192"><a href="#cb3-1192" aria-hidden="true" tabindex="-1"></a>resLVIRF[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predLVIRF <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1193"><a href="#cb3-1193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1194"><a href="#cb3-1194" aria-hidden="true" tabindex="-1"></a><span class="do">#### Case Specific Random Forests</span></span>
<span id="cb3-1195"><a href="#cb3-1195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1196"><a href="#cb3-1196" aria-hidden="true" tabindex="-1"></a><span class="do">## Nmin = 5</span></span>
<span id="cb3-1197"><a href="#cb3-1197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1198"><a href="#cb3-1198" aria-hidden="true" tabindex="-1"></a>predCsrf5 <span class="ot">&lt;-</span> <span class="fu">csrf</span>(mod<span class="sc">~</span>., <span class="at">training_data =</span> data.train, <span class="at">test_data =</span> <span class="fu">data.frame</span>(x.test), <span class="at">params1 =</span> <span class="fu">list</span>(<span class="at">num.trees=</span><span class="dv">100</span>, <span class="at">mtry =</span> <span class="fu">dim</span>(x.train)[<span class="dv">2</span>], <span class="at">min.node.size =</span> <span class="dv">5</span>, <span class="at">num.threads =</span> ncores), <span class="at">params2 =</span> <span class="fu">list</span>(<span class="at">num.trees=</span><span class="dv">100</span>, <span class="at">num.threads =</span> ncores))</span>
<span id="cb3-1199"><a href="#cb3-1199" aria-hidden="true" tabindex="-1"></a>resCsrf5[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predCsrf5 <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1200"><a href="#cb3-1200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1201"><a href="#cb3-1201" aria-hidden="true" tabindex="-1"></a><span class="do">## Nmin = 10</span></span>
<span id="cb3-1202"><a href="#cb3-1202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1203"><a href="#cb3-1203" aria-hidden="true" tabindex="-1"></a>predCsrf10 <span class="ot">&lt;-</span> <span class="fu">csrf</span>(mod<span class="sc">~</span>., <span class="at">training_data =</span> data.train, <span class="at">test_data =</span> <span class="fu">data.frame</span>(x.test), <span class="at">params1 =</span> <span class="fu">list</span>(<span class="at">num.trees=</span><span class="dv">100</span>, <span class="at">mtry =</span> <span class="fu">dim</span>(x.train)[<span class="dv">2</span>], <span class="at">min.node.size =</span> <span class="dv">10</span>, <span class="at">num.threads =</span> ncores), <span class="at">params2 =</span> <span class="fu">list</span>(<span class="at">num.trees=</span><span class="dv">100</span>, <span class="at">num.threads =</span> ncores))</span>
<span id="cb3-1204"><a href="#cb3-1204" aria-hidden="true" tabindex="-1"></a>resCsrf10[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predCsrf10 <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1205"><a href="#cb3-1205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1206"><a href="#cb3-1206" aria-hidden="true" tabindex="-1"></a><span class="do">#### Local dynamic selection RF</span></span>
<span id="cb3-1207"><a href="#cb3-1207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1208"><a href="#cb3-1208" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"DynamicVotingWithSelectionRF.R"</span>)</span>
<span id="cb3-1209"><a href="#cb3-1209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1210"><a href="#cb3-1210" aria-hidden="true" tabindex="-1"></a><span class="do">## 100 neighbors, we keep 100 best trees (all)</span></span>
<span id="cb3-1211"><a href="#cb3-1211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1212"><a href="#cb3-1212" aria-hidden="true" tabindex="-1"></a>predDVSRF1 <span class="ot">&lt;-</span> <span class="fu">dynamicVoting</span>(<span class="at">formula =</span> mod<span class="sc">~</span>., <span class="at">data =</span> data.train, <span class="at">dataTest =</span> <span class="fu">data.frame</span>(x.test), <span class="at">K =</span> <span class="dv">100</span>, <span class="at">ntree =</span> <span class="dv">100</span>, <span class="at">ntreeToKeep =</span> <span class="dv">100</span>, <span class="at">ncores =</span> ncores)</span>
<span id="cb3-1213"><a href="#cb3-1213" aria-hidden="true" tabindex="-1"></a>resDVSRF1[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predDVSRF1<span class="sc">$</span>prediction <span class="sc">!=</span>  classeTest)</span>
<span id="cb3-1214"><a href="#cb3-1214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1215"><a href="#cb3-1215" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"KernelVotingRF.R"</span>)</span>
<span id="cb3-1216"><a href="#cb3-1216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1217"><a href="#cb3-1217" aria-hidden="true" tabindex="-1"></a><span class="do">## alpha = 0.5</span></span>
<span id="cb3-1218"><a href="#cb3-1218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1219"><a href="#cb3-1219" aria-hidden="true" tabindex="-1"></a>predKVRF1 <span class="ot">&lt;-</span> <span class="fu">kernelVoting</span>(<span class="at">formula =</span> mod<span class="sc">~</span>., <span class="at">data =</span> data.train, <span class="at">dataTest =</span> <span class="fu">data.frame</span>(x.test), <span class="at">ntree =</span> <span class="dv">100</span>, <span class="at">ncores =</span> ncores, <span class="at">rule =</span> <span class="st">"quantile"</span>, <span class="at">alpha =</span> <span class="fl">0.5</span>)</span>
<span id="cb3-1220"><a href="#cb3-1220" aria-hidden="true" tabindex="-1"></a>resKVRF1[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predKVRF1<span class="sc">$</span>prediction <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1221"><a href="#cb3-1221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1222"><a href="#cb3-1222" aria-hidden="true" tabindex="-1"></a><span class="do">#### Nearest-neighbors followed by classic RF</span></span>
<span id="cb3-1223"><a href="#cb3-1223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1224"><a href="#cb3-1224" aria-hidden="true" tabindex="-1"></a>madInit <span class="ot">&lt;-</span> <span class="fu">apply</span>(<span class="at">X =</span> x.train, <span class="dv">2</span>, mad)</span>
<span id="cb3-1225"><a href="#cb3-1225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1226"><a href="#cb3-1226" aria-hidden="true" tabindex="-1"></a><span class="do">## 100 NN</span></span>
<span id="cb3-1227"><a href="#cb3-1227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1228"><a href="#cb3-1228" aria-hidden="true" tabindex="-1"></a>K <span class="ot">&lt;-</span> <span class="dv">250</span></span>
<span id="cb3-1229"><a href="#cb3-1229" aria-hidden="true" tabindex="-1"></a>predNNRF1 <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">c</span>(),<span class="at">levels=</span><span class="fu">levels</span>(data.train<span class="sc">$</span>mod))</span>
<span id="cb3-1230"><a href="#cb3-1230" aria-hidden="true" tabindex="-1"></a><span class="co"># tp &lt;- txtProgressBar(min = 1, max = nTest, style = 3, char = "*")</span></span>
<span id="cb3-1231"><a href="#cb3-1231" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nTest)</span>
<span id="cb3-1232"><a href="#cb3-1232" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb3-1233"><a href="#cb3-1233" aria-hidden="true" tabindex="-1"></a>  distances <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span>n, <span class="cf">function</span>(X) <span class="fu">sqrt</span>(<span class="fu">mean</span>( ( (x.train[X,]<span class="sc">-</span>x.test[i,])<span class="sc">/</span>madInit )<span class="sc">^</span><span class="dv">2</span>)) )</span>
<span id="cb3-1234"><a href="#cb3-1234" aria-hidden="true" tabindex="-1"></a>  ord <span class="ot">&lt;-</span> <span class="fu">order</span>(distances)</span>
<span id="cb3-1235"><a href="#cb3-1235" aria-hidden="true" tabindex="-1"></a>  toKeep <span class="ot">&lt;-</span> ord[<span class="dv">1</span><span class="sc">:</span>K]</span>
<span id="cb3-1236"><a href="#cb3-1236" aria-hidden="true" tabindex="-1"></a>  data.trainNN <span class="ot">&lt;-</span> data.train[toKeep,]</span>
<span id="cb3-1237"><a href="#cb3-1237" aria-hidden="true" tabindex="-1"></a>  rfNN <span class="ot">&lt;-</span> <span class="fu">ranger</span>(<span class="at">formula =</span> mod<span class="sc">~</span>., <span class="at">data =</span> data.trainNN, <span class="at">num.trees =</span> <span class="dv">100</span>, <span class="at">num.threads=</span>ncores)</span>
<span id="cb3-1238"><a href="#cb3-1238" aria-hidden="true" tabindex="-1"></a>  predNNRF1[i] <span class="ot">&lt;-</span> <span class="fu">predict</span>(rfNN, <span class="at">data=</span><span class="fu">data.frame</span>(x.test[i,,<span class="at">drop=</span><span class="cn">FALSE</span>]), <span class="at">num.threads=</span>ncores)<span class="sc">$</span>predictions</span>
<span id="cb3-1239"><a href="#cb3-1239" aria-hidden="true" tabindex="-1"></a><span class="co">#  setTxtProgressBar(tp, i)</span></span>
<span id="cb3-1240"><a href="#cb3-1240" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-1241"><a href="#cb3-1241" aria-hidden="true" tabindex="-1"></a>resNNRF1[k] <span class="ot">&lt;-</span> <span class="fu">mean</span>(predNNRF1 <span class="sc">!=</span> classeTest)</span>
<span id="cb3-1242"><a href="#cb3-1242" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-1243"><a href="#cb3-1243" aria-hidden="true" tabindex="-1"></a>resTOT <span class="ot">&lt;-</span> <span class="fu">cbind</span>(resBayes,resBagging,resRF,resLVIRF,resCsrf5,resCsrf10,resDVSRF1,resKVRF1,resNNRF1)</span>
<span id="cb3-1244"><a href="#cb3-1244" aria-hidden="true" tabindex="-1"></a>resTOT<span class="ot">&lt;-</span><span class="dv">100</span><span class="sc">*</span>resTOT</span>
<span id="cb3-1245"><a href="#cb3-1245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1246"><a href="#cb3-1246" aria-hidden="true" tabindex="-1"></a>Identifier<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"Bayes classifier"</span>,<span class="st">"Bagged CARTs"</span>,<span class="st">"Random forest"</span>,<span class="st">"LVI-RF"</span>,<span class="st">"CSRF"</span>,<span class="st">"CSRF"</span>,<span class="st">"DVSRF"</span>,<span class="st">"KV-RF"</span>,<span class="st">"NN-RF"</span>)</span>
<span id="cb3-1247"><a href="#cb3-1247" aria-hidden="true" tabindex="-1"></a>Characteristics<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">""</span>,<span class="st">"Nmin=5"</span>,<span class="st">"Nmin=10"</span>,<span class="st">"k=100,Bsel=100"</span>,<span class="st">""</span>,<span class="st">"k=250"</span>)</span>
<span id="cb3-1248"><a href="#cb3-1248" aria-hidden="true" tabindex="-1"></a>Table<span class="ot">=</span><span class="fu">cbind</span>(Identifier,Characteristics,<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,mean),<span class="fu">paste</span>(<span class="st">"("</span>,<span class="fu">round</span>(<span class="fu">apply</span>(resTOT,<span class="dv">2</span>,sd),<span class="dv">2</span>),<span class="st">")"</span>,<span class="at">sep=</span><span class="st">""</span>))</span>
<span id="cb3-1249"><a href="#cb3-1249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1250"><a href="#cb3-1250" aria-hidden="true" tabindex="-1"></a>TableOrdered<span class="ot">=</span>Table[<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,<span class="dv">5</span><span class="sc">:</span><span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">4</span>,<span class="dv">7</span>,<span class="dv">8</span>),]</span>
<span id="cb3-1251"><a href="#cb3-1251" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(TableOrdered)<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Method"</span>,<span class="st">"Parameters"</span>,<span class="st">"Error rate"</span>,<span class="st">"(sd)"</span>)</span>
<span id="cb3-1252"><a href="#cb3-1252" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(TableOrdered)<span class="ot">=</span><span class="cn">NULL</span></span>
<span id="cb3-1253"><a href="#cb3-1253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1254"><a href="#cb3-1254" aria-hidden="true" tabindex="-1"></a>kableExtra<span class="sc">::</span><span class="fu">kable</span>(TableOrdered, <span class="at">booktabs=</span>T, <span class="at">row.names=</span><span class="cn">NA</span>)</span>
<span id="cb3-1255"><a href="#cb3-1255" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1256"><a href="#cb3-1256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1257"><a href="#cb3-1257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1258"><a href="#cb3-1258" aria-hidden="true" tabindex="-1"></a><span class="fu"># Discussions {#sec-discussions}</span></span>
<span id="cb3-1259"><a href="#cb3-1259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1260"><a href="#cb3-1260" aria-hidden="true" tabindex="-1"></a>In this paper, we review, discuss and propose local tree-based methods strategies taking into account a specific instance during the learning process in the context of classification problems. </span>
<span id="cb3-1261"><a href="#cb3-1261" aria-hidden="true" tabindex="-1"></a>The results are not up to our expectations. We considered four examples where local methods seemed useful but we did not obtained conclusive results.</span>
<span id="cb3-1262"><a href="#cb3-1262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1263"><a href="#cb3-1263" aria-hidden="true" tabindex="-1"></a>Our proposal to introduce weights in the splitting criterion (see @sec-localSplittingRules): LazyDT and kernel approaches) is problematic. </span>
<span id="cb3-1264"><a href="#cb3-1264" aria-hidden="true" tabindex="-1"></a>Putting too high weights around $\xs$ results in irrelevant cut-points, closer to $\xs$ </span>
<span id="cb3-1265"><a href="#cb3-1265" aria-hidden="true" tabindex="-1"></a>compared to RF. It induces large correlations between the trees in the forest, and the </span>
<span id="cb3-1266"><a href="#cb3-1266" aria-hidden="true" tabindex="-1"></a>quality of prediction is impacted negatively. This is why for the kernel approaches a bandwith of quantile $\alpha=1$ is preferred. With this choice, </span>
<span id="cb3-1267"><a href="#cb3-1267" aria-hidden="true" tabindex="-1"></a>even if it localized the trees, we obtained results very similar if not worse than those of RF, at the cost of very high computational complexity. Less computationally intensive but as disappointing is the kernel voting RF strategy.</span>
<span id="cb3-1268"><a href="#cb3-1268" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-1269"><a href="#cb3-1269" aria-hidden="true" tabindex="-1"></a>The CSRF of @xu:etal:2016 (see @sec-weightingIndividuals), the nearest</span>
<span id="cb3-1270"><a href="#cb3-1270" aria-hidden="true" tabindex="-1"></a>neighbor weights (@sec-nearest-neighbours) and the local weighting </span>
<span id="cb3-1271"><a href="#cb3-1271" aria-hidden="true" tabindex="-1"></a>of covariates (@sec-weightingCovariates) strategies can give good performance but depend on tuning parameters.</span>
<span id="cb3-1272"><a href="#cb3-1272" aria-hidden="true" tabindex="-1"></a>For instance, the CSRF brings better performance when the tree depth is low, i.e. high $\Nmin$.</span>
<span id="cb3-1273"><a href="#cb3-1273" aria-hidden="true" tabindex="-1"></a>However, generally, results provided by these local methods are very similar to eager ones, and no great benefit is observed on our three examples.</span>
<span id="cb3-1274"><a href="#cb3-1274" aria-hidden="true" tabindex="-1"></a>When looking at the very small benefits in terms of prediction error rate compared to the non-local approaches, we can say that local strategies are clearly not worth the additional computational cost. Especially since most of them require the choice </span>
<span id="cb3-1275"><a href="#cb3-1275" aria-hidden="true" tabindex="-1"></a>of a tuning parameter, characterizing the weights given to instances surrounding $\xs$.</span>
<span id="cb3-1276"><a href="#cb3-1276" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-1277"><a href="#cb3-1277" aria-hidden="true" tabindex="-1"></a>We have not considered here the case of regression problems, for which local tree-based methods have also been proposed. For instance the CSRF, the nearest neighbor weights and the dynamic voting with selection random forests are directly applicable to regression forests, and in most cases already implemented. Similarly, our propositions regarding local weighting of covariates, and local splitting criterion using kernels would easily be extendable to regression problems. In a local regression framework, @friedberg2020local consider a two-step approach where the response $y^\star$ is predicted from a locally weighted ridge regression using weights from a modified random forest. This forest is built with a modified splitting criterion which minimizes the residuals in each leaf after fitting a ridge regression to predict $y_j$ from $x_j$.</span>
<span id="cb3-1278"><a href="#cb3-1278" aria-hidden="true" tabindex="-1"></a>Whether these methods improve the original random forest in the case of regression is still an open question, but our results in the case of classification are not optimistic.</span>
<span id="cb3-1279"><a href="#cb3-1279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1280"><a href="#cb3-1280" aria-hidden="true" tabindex="-1"></a><span class="fu"># Acknowledgements</span></span>
<span id="cb3-1281"><a href="#cb3-1281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1282"><a href="#cb3-1282" aria-hidden="true" tabindex="-1"></a>We thank the referees for their very helpful suggestions, helping us to improve the quality of that paper. We also express gratitude to the Associate Editor Nelle Varoquaux and the Editor Julien Chiquet for dedicating their time to this paper and for their responses to our numerous inquiries about the tools.</span>
<span id="cb3-1283"><a href="#cb3-1283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1284"><a href="#cb3-1284" aria-hidden="true" tabindex="-1"></a><span class="fu"># Funding </span></span>
<span id="cb3-1285"><a href="#cb3-1285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1286"><a href="#cb3-1286" aria-hidden="true" tabindex="-1"></a>This work was supported by the French National Research Agency (ANR) through the project ANR-18-CE40-0034 (ABSint).</span>
<span id="cb3-1287"><a href="#cb3-1287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1288"><a href="#cb3-1288" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb3-1289"><a href="#cb3-1289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1290"><a href="#cb3-1290" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb3-1291"><a href="#cb3-1291" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-1292"><a href="#cb3-1292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1293"><a href="#cb3-1293" aria-hidden="true" tabindex="-1"></a><span class="fu"># Session information {.appendix .unnumbered}</span></span>
<span id="cb3-1294"><a href="#cb3-1294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1295"><a href="#cb3-1295" aria-hidden="true" tabindex="-1"></a><span class="in">```{r session-info}</span></span>
<span id="cb3-1296"><a href="#cb3-1296" aria-hidden="true" tabindex="-1"></a><span class="in">sessionInfo()</span></span>
<span id="cb3-1297"><a href="#cb3-1297" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>